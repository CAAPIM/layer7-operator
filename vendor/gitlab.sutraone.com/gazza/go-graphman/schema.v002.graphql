"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type ActiveConnector {
  """The goid for the active connector"""
  goid: ID!

  """The active connector name"""
  name: String!

  """Whether this active connector is enabled"""
  enabled: Boolean!

  """The active connector type - KAFKA, SFTP_POLLING_LISTENER, MQ_NATIVE"""
  connectorType: ActiveConnectorType!

  """The name of the published service hardwired to the active connector"""
  hardwiredServiceName: String

  """The published service hardwired to the active connector"""
  hardwiredService: HardwiredService

  """The active connector Properties"""
  properties: [EntityProperty!]

  """The advanced properties for active connector"""
  advancedProperties: [EntityProperty!]

  """The configuration checksum of this active connector"""
  checksum: String!
}

input ActiveConnectorInput {
  """The internal entity unique identifier"""
  goid: ID

  """The active connector name"""
  name: String!

  """Whether this active connector is enabled"""
  enabled: Boolean!

  """The active connector type - KAFKA, SFTP_POLLING_LISTENER, MQ_NATIVE"""
  connectorType: ActiveConnectorType!

  """The name of the published service hardwired to the active connector"""
  hardwiredServiceName: String

  """The active connector properties"""
  properties: [EntityPropertyInput!]

  """The advanced properties for active connector"""
  advancedProperties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ActiveConnectorsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated active connectors"""
  activeConnectors: [ActiveConnector]!
}

enum ActiveConnectorType {
  KAFKA
  SFTP_POLLING_LISTENER
  MQ_NATIVE
}

type BackgroundTaskPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  backgroundTaskPolicies: [BackgroundTaskPolicy]!
}

"""
A background task policy that is associated with a scheduled task to be run
"""
type BackgroundTaskPolicy {
  """The name of the background task policy"""
  name: String!

  """The folder path of the background task policy"""
  folderPath: String!

  """The internal entity unique identifier"""
  guid: ID!

  """The internal entity unique identifier"""
  goid: ID!

  """The background task policy"""
  policy: Policy!
  soap: Boolean

  """The configuration checksum"""
  checksum: String!
}

input BackgroundTaskPolicyInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the background task policy"""
  name: String!

  """The internal entity unique identifier"""
  guid: ID

  """The folder path background task policy"""
  folderPath: String!

  """The background task policy"""
  policy: PolicyInput!
  soap: Boolean

  """The configuration checksum"""
  checksum: String
}

enum CassandraCompression {
  NONE
  LZ4
}

"""A Cassandra Connection"""
type CassandraConnection {
  """The goid for the Cassandra Connection"""
  goid: ID!

  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String!

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The username"""
  username: String

  """The secure password reference."""
  securePasswordName: String

  """The Cassandra connection compression type"""
  compression: CassandraCompression!

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra connection properties"""
  properties: [EntityProperty!]

  """The configuration checksum of this Cassandra connection"""
  checksum: String!
}

input CassandraConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String! = ""

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The username"""
  username: String! = ""

  """The secure password reference."""
  securePasswordName: String

  """The Cassandra connection compression type"""
  compression: CassandraCompression = NONE

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra connection properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type CassandraConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated Cassandra connections."""
  cassandraConnections: [CassandraConnection]!
}

"""An certificate that is trusted by the Gateway"""
type Certificate {
  """The goid for this certificate"""
  goid: ID!

  """The name"""
  name: String!

  """The Subject DN of this certificate"""
  subjectDn: String!

  """The start date of the validity period"""
  notBefore: DateTime!

  """the end date of the validity period"""
  notAfter: DateTime!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """The certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The base 64 encoded string of this certificate"""
  certBase64: String!

  """The sha1 thumbprint of the certificate"""
  thumbprintSha1: String!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """The specified revocation policy"""
  revocationCheckPolicy: RevocationCheckPolicy

  """The configuration checksum of this trusted certificate"""
  checksum: String!
}

enum CertificateValidationType {
  CERTIFICATE_ONLY
  PATH_VALIDATION
  REVOCATION
}

type ClusterPropertiesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  clusterProperties: [ClusterProperty]!
}

"""Cluster properties are used to set global properties"""
type ClusterProperty {
  """The goid for the cluster property"""
  goid: ID!

  """The cluster property name"""
  name: String!

  """The cluster property value"""
  value: String!

  """The cluster property description"""
  description: String

  """Whether this is a hidden property"""
  hiddenProperty: Boolean!

  """The configuration checksum of this cluster prop"""
  checksum: String!
}

"""The inputs sent with the setClusterProperty Mutation"""
input ClusterPropertyInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the cluster property"""
  name: String!

  """The value of the cluster property to set"""
  value: String!

  """The cluster property description"""
  description: String

  """
  Whether this is a hidden property. (Note that, this field has no effect on the mutation)
  """
  hiddenProperty: Boolean

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

enum DataType {
  STRING
  CERTIFICATE
  INTEGER
  DECIMAL
  FLOAT
  ELEMENT
  BOOLEAN
  BINARY
  DATE_TIME
  MESSAGE
  BLOB
  CLOB
  UNKNOWN
}

"""
An RFC-3339 compliant date time scalar that accepts string values like `1996-12-19T16:39:57-08:00`
"""
scalar DateTime

"""A Document Type Definition (DTD) which can be referred to in policy"""
type Dtd {
  """Internal goid for this DTD"""
  goid: ID!

  """
  A reference to the DTD. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The public id for the DTD"""
  publicId: String

  """An optional description"""
  description: String

  """The content of DTD itself"""
  content: String!

  """The configuration checksum"""
  checksum: String!
}

input DtdInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the dtd. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The public id for the dtd"""
  publicId: String

  """An optional description"""
  description: String

  """The actual dtd itself"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type DtdsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  dtds: [Dtd]!
}

type EmailListener {
  """The goid for the email listener Connection"""
  goid: ID!

  """
  The name of the email listener. If you are creating several listeners, make sure the name is descriptive
  """
  name: String!

  """Whether this email listener is enabled(active)"""
  enabled: Boolean!

  """
  The hostname of the email server. This name is verified against the X.509 certificate
  """
  hostname: String!

  """The port number to monitor"""
  port: PositiveInt!

  """The type of email server (IMAP or POP3)"""
  serverType: EmailServerType!

  """Whether email server connection (POP3S or IMAPS) is SSL enabled"""
  sslEnabled: Boolean!

  """Whether delete the messages on the mail server after retrieving"""
  deleteOnReceive: Boolean!

  """The folder name to check for emails (Only for IMAP)"""
  folder: String!

  """
  The listener will check for email after the specified number of seconds
  """
  pollInterval: PositiveInt!

  """Email account name"""
  username: String!

  """
  Email account password. The password could be in plain text or secure password reference
  """
  password: String!

  """The name of the published service hardwired to the email listener"""
  hardwiredServiceName: String

  """The published service hardwired to the email listener"""
  hardwiredService: HardwiredService

  """Permitted maximum size of the message"""
  sizeLimit: PositiveInt

  """
  The email listener properties excluding sizeLimit and HardwiredServiceName
  """
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

input EmailListenerInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The name of the email listener. If you are creating several listeners, make sure the name is descriptive
  """
  name: String!

  """Whether this email listener is enabled(active)"""
  enabled: Boolean!

  """
  The hostname of the email server. This name is verified against the X.509 certificate
  """
  hostname: NonEmptyString!

  """The port number to monitor"""
  port: PositiveInt!

  """The type of email server (IMAP or POP3)"""
  serverType: EmailServerType!

  """Whether email server connection (POP3S or IMAPS) is SSL enabled"""
  sslEnabled: Boolean!

  """Whether delete the messages on the mail server after retrieving"""
  deleteOnReceive: Boolean!

  """The folder name to check for emails (Only for IMAP)"""
  folder: String!

  """
  The listener will check for email after the specified number of seconds
  """
  pollInterval: PositiveInt!

  """Email account name"""
  username: String!

  """
  Email account password. The password could be in plain text or secure password reference
  """
  password: String!

  """The name of the published service hardwired to the email listener"""
  hardwiredServiceName: String

  """Permitted maximum size of the message"""
  sizeLimit: PositiveInt

  """
  [Optional] The Email listener Properties excluding sizeLimit and
  HardwiredServiceName. When specified, will replace existing properties
  """
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type EmailListenersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated email listener connections."""
  emailListeners: [EmailListener]!
}

enum EmailServerType {
  IMAP
  POP3
}

"""The description of an input argument for an encapsulated assertion"""
type EncassArg {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: Boolean

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""
The description of an input argument for an encapsulated assertion for use when
creating or updating an existing encass config
"""
input EncassArgInput {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: Boolean = false

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""An Encapsulated Assertion Configuration"""
type EncassConfig {
  """The name of the encass config"""
  name: String!
  description: String

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArg!]

  """the output descriptions"""
  encassResults: [EncassResult!]
  properties: [EntityProperty!]

  """The goid for this encass config"""
  goid: ID!

  """The guid for this encass config"""
  guid: ID!

  """The configuration checksum of this encass"""
  checksum: String!
}

"""
The description of a new encapsulated assertion configuration being created
"""
input EncassConfigInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The guid for this encass config, can be omitted and a new one is assigned
  """
  guid: ID

  """The name of the encass config"""
  name: String!
  description: String

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArgInput!]

  """the output descriptions"""
  encassResults: [EncassResultInput!]
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type EncassConfigsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  encassConfigs: [EncassConfig]!
}

"""The description of an output from the encapsulated assertion"""
type EncassResult {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

"""
The description of an output from the encapsulated assertion for use when creating or updating an existing encass config
"""
input EncassResultInput {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

type EntityMutationDetailedStatus {
  status: EntityMutationStatus!
  description: String
}

interface EntityMutationPayload {
  status: EntityMutationStatus!
  detailedStatus: EntityMutationDetailedStatus!
}

interface EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
}

enum EntityMutationStatus {
  NONE
  CREATED
  UPDATED
  DELETED
  ERROR
}

"""An Entity Property"""
type EntityProperty {
  """The name of property"""
  name: String!

  """The value of the property"""
  value: String!
}

input EntityPropertyInput {
  name: String!
  value: String!
}

"""A Federated Identity Provider"""
type Fip {
  name: String!
  goid: ID!
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!
  certificateValidation: CertificateValidationType

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [Certificate!]!
  checksum: String!
}

input FipCertInput {
  """
  The thumbprint of the cert to use as trust for a federated identity provider
  """
  thumbprintSha1: String!

  """
  The internal entity unique identifier. (Note that, this field has no effect on the mutation)
  """
  goid: ID

  """
  The name of the trusted certificate. (Note that, this field has no effect on the mutation)
  """
  name: String

  """
  The base 64 encoded string of the certificate. (Note that, this field has no effect on the mutation)
  """
  certBase64: String

  """
  Whether to perform hostname verification with this certificate. (Note that, this field has no effect on the mutation)
  """
  verifyHostname: Boolean

  """
  Whether this certificate is a trust anchor. (Note that, this field has no effect on the mutation)
  """
  trustAnchor: Boolean

  """
  What the certificate is trusted for. (Note that, this field has no effect on the mutation)
  """
  trustedFor: [TrustedForType!]

  """
  The revocation check policy type. (Note that, this field has no effect on the mutation)
  """
  revocationCheckPolicyType: PolicyUsageType

  """
  The name of revocation policy. (Note that, this field has no effect on the mutation)
  """
  revocationCheckPolicyName: String

  """
  The Subject DN of this certificate. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """
  The start date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notBefore: String

  """
  the end date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notAfter: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

""" A group defined in a federated identity provider"""
type FipGroup {
  name: String!
  goid: ID!

  """ The name of the FiP this group is defined in """
  providerName: String!
  description: String

  """ Fip users that member of this group """
  members: [FipUser!]!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
}

input FipGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this group is defined in """
  providerName: String!
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type FipGroupsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fipGroups: [FipGroup]!
}

input FipInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!
  certificateValidation: CertificateValidationType

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [FipCertInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String
}

type FipSearchResult {
  fipUsers: [FipUser!]!
  fipGroups: [FipGroup!]!
}

type FipsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fips: [Fip]!
}

""" A user defined in a federated identity provider """
type FipUser {
  name: String!
  goid: ID!

  """ The name of the FiP this user is defined as part of """
  providerName: String!

  """ The list of Fip groups this user belongs to """
  memberOf: [FipGroup!]!
  login: String
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  checksum: String!
}

input FipUserInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this user is defined as part of """
  providerName: String!

  """
  The list of fip group names that this user is member of. If you pass empty
  array, will reset memberships. If absent, does not affect memberships for current user.
  """
  memberOf: [MembershipInput!]
  login: String
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  checksum: String!
}

type FipUsersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fipUsers: [FipUser]!
}

type GlobalPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  globalPolicies: [GlobalPolicy]!
}

"""A Global policy"""
type GlobalPolicy {
  """The name of the policy (policies are unique by name)"""
  name: String!

  """The folder path where this policy is located"""
  folderPath: String!

  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The actual policy and dependencies"""
  policy: Policy!

  """The configuration checksum"""
  checksum: String!
}

input GlobalPolicyInput {
  """The name of the policy. Policies are unique by name."""
  name: String!

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The goid for this policy"""
  goid: ID

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The policy"""
  policy: PolicyInput!
  soap: Boolean = false

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""
enum UserCertificateUseType {
   NONE
   INDEX
   INDEX_CUSTOM
   SEARCH
}
"""
type GroupMapping {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategy!
}

input GroupMappingInput {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategyInput!
}

union HardwiredService = SoapService | WebApiService

"""Support Http methods for Web API Service"""
enum HttpMethod {
  DELETE
  HEAD
  GET
  POST
  PUT
  OPTIONS
  PATCH
  OTHER
}

""" Indicate how to search for group or user. Provide either a name pattern, a subject dn and or a goid. 
"""
input IdpFilter {
  """ The name of the FiP provider, or 'Internal' """
  providerName: String!

  """
  Finds users and groups whose name matches the specified pattern. May include wildcard such as * character
  """
  namePattern: String

  """ SubjectDN of a FIP user """
  subjectDn: String

  """ Get entity by goid """
  goid: ID
}

""" A group of users defined in the internal identity provider """
type InternalGroup {
  name: String!
  goid: ID!
  description: String

  """ The list of internal users that are part of this group """
  members: [InternalUser!]!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
}

input InternalGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type InternalGroupsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalGroups: [InternalGroup]!
}

type InternalSearchResult {
  internalUsers: [InternalUser!]!
  internalGroups: [InternalGroup!]!
}

"""A Soap service published on the Layer7 Gateway"""
type InternalSoapService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String

  """The folder path to the service"""
  folderPath: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """Soap service resolvers"""
  resolvers: SoapResolvers!

  """Which SOAP version"""
  soapVersion: SoapVersion!
  wssProcessingEnabled: Boolean!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed if not just POST"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

type InternalSoapServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalSoapServices: [InternalSoapService]!
}

""" A user in the internal identity provider """
type InternalUser {
  name: String!
  goid: ID!

  """ List of groups this is member of """
  memberOf: [InternalGroup!]!
  login: String

  """The hashed password of the user if defined"""
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  enabled: Boolean!
  checksum: String!
}

input InternalUserInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """
  The list of internal group names that this user is member of. If you pass
  empty array, will reset memberships. If absent, does not affect memberships
  for current users.
  """
  memberOf: [MembershipInput!]
  login: String!

  """
  You can either pass in the hashed password which comes back in queries or the raw passwd directly
  """
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type InternalUsersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalUsers: [InternalUser]!
}

"""A Internal Web API service published on the Layer7 Gateway"""
type InternalWebApiService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String!

  """The folder path to the service"""
  folderPath: String!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

type InternalWebApiServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalWebApiServices: [InternalWebApiService]!
}

"""A JDBC Connection"""
type JdbcConnection {
  """The goid for the JDBC Connection"""
  goid: ID!

  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean!

  """The username"""
  username: String!

  """The password or the secure password reference."""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt!

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt!

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityProperty!]

  """The configuration checksum of this JDBC connection"""
  checksum: String!
}

input JdbcConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean! = true

  """The username"""
  username: String!

  """The password or the secured password reference"""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt! = 3

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt! = 15

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input JdbcConnectionPartialInput {
  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String

  """The JDBC url"""
  jdbcUrl: String

  """Whether this JDBC connection is enabled"""
  enabled: Boolean

  """The username"""
  username: String

  """The password or the secured password reference"""
  password: String

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt

  """
  The JDBC connection properties excluding 'user' and 'password'.  When specified, will replace all existing properties
  """
  properties: [EntityPropertyInput!]
}

type JdbcConnectionPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  detailedStatus: EntityMutationDetailedStatus!

  """The created JDBC connection."""
  jdbcConnection: JdbcConnection
}

type JdbcConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created/updated JDBC connections."""
  jdbcConnections: [JdbcConnection]!
}

"""A JMS Destination"""
type JmsDestination {
  """The goid for the JMS Destination"""
  goid: ID!

  """The goid for the JMS Connection"""
  connectionGoid: ID!

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String!

  """The JMS provider type"""
  providerType: String!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetails!

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetails!

  """Whether this JMS destination is template"""
  template: Boolean!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityProperty!]

  """The configuration checksum of this JMS destination"""
  checksum: String!
}

input JmsDestinationInput {
  """The internal entity unique identifier"""
  goid: ID
  connectionGoid: ID

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String!

  """The JMS provider type"""
  providerType: String!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetailsInput

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetailsInput

  """Whether this JMS destination is template"""
  template: Boolean!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type JmsDestinationsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created/updated JMS destinations."""
  jmsDestinations: [JmsDestination]!
}

"""A JMS SSL Details"""
type JmsSslDetails {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

input JmsSslDetailsInput {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

"""Defines a current status of a given scheduled task"""
enum JobStatus {
  SCHEDULED
  COMPLETED
  DISABLED
}

"""Defines a scheduled task type"""
enum JobType {
  ONE_TIME
  RECURRING
}

"""
This is an entry in the gateway keystore. These entries combine a private
key and associated certificate and are used for example by listener ports
These represent the gateway's own certificates as opposed to the Certificate
type which represent a cert trusted by the gateway.
"""
type Key {
  """The gateway keystore identifier"""
  keystoreId: ID!

  """The name assigned to the key"""
  alias: String!

  """The subjectDN"""
  subjectDn: String!

  """The internal entity unique identifier"""
  goid: ID!

  """The configuration checksum"""
  checksum: String!

  """The type of the private key"""
  keyType: String!

  """The certificate chain in PEM format"""
  certChain: [String!]!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String!
}

input KeyInput {
  keystoreId: ID
  alias: String!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String!

  """Will try to match at creation time is specified"""
  goid: ID

  """
  SubjectDn of the certificate associated with the key. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """Key type. (Note that, this field has no effect on the mutation)"""
  keyType: String

  """
  The certificate chain in PEM format. (Note that, this field has no effect on the mutation)
  """
  certChain: [String!]

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String
}

type KeysPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  keys: [Key]!
}

"""
LdapIdp config itself is provided. Graphman wont get to
underlying users and groups in the ldap since they are not
part of the gateway configuration itself. When l7 policies
refer to these ldap users and groups, thee references are
interpreted by the ldap directory itself.
"""
type Ldap {
  name: String!
  goid: ID!
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """The ID of the gateway keystore where the key is located"""
  ldapsClientKeystoreId: ID

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMapping!]!
  groupMappings: [GroupMapping!]!

  """
  consider these advanced ldap configuration:
  userCertificateUseType : UserCertificateUseType!
  ntlm stuff, 8 settings and additional arbitrary props
  6 additional user cert settings
  """
  checksum: String!
}

input LdapInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID!
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """The ID of the gateway keystore where the key is located"""
  ldapsClientKeystoreId: ID

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMappingInput!]!
  groupMappings: [GroupMappingInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String!
}

type LdapsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  ldaps: [Ldap]!
}

type ListenPort {
  """The internal entity unique identifier"""
  goid: ID!

  """The listen port configuration name"""
  name: String!

  """Whether this listen port configuration is enabled"""
  enabled: Boolean!

  """
  Protocol (scheme). Possible values are:
      HTTP
      HTTPS
      HTTP2
      HTTP2 (Secure)
      FTP
      FTPS
      l7.raw.tcp
      SSH2
  """
  protocol: String!

  """
  The ListenPort's port number
  Note: If the listen port is using the SSH2 protocol, avoid using port 22, as
  it may conflict with the default SSH port 22 on Linux or Unix systems.
  """
  port: PositiveInt!

  """The name of the published service hardwired to the listen port"""
  hardwiredServiceName: String

  """The published service hardwired to the listen port"""
  hardwiredService: HardwiredService

  """Which Gateway services can be accessed through this listen port"""
  enabledFeatures: [ListenPortFeature!]!

  """The listen port tls settings"""
  tlsSettings: ListenPortTlsSettings

  """The listen port properties"""
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

enum ListenPortClientAuth {
  NONE
  OPTIONAL
  REQUIRED
}

enum ListenPortFeature {
  PUBLISHED_SERVICE_MESSAGE_INPUT
  POLICY_MANAGER_ACCESS
  ENTERPRISE_MANAGER_ACCESS
  ADMINISTRATIVE_ACCESS
  BROWSER_BASED_ADMINISTRATION
  POLICY_DOWNLOAD_SERVICE
  PING_SERVICE
  WS_TRUST_SECURITY_TOKEN_SERVICE
  CERTIFICATE_SIGNING_SERVICE
  PASSWORD_CHANGING_SERVICE
  WSDL_DOWNLOAD_SERVICE
  SNMP_QUERY_SERVICE
  BUILT_IN_SERVICES
  NODE_CONTROL
  INTER_NODE_COMMUNICATION
}

input ListenPortInput {
  """The internal entity unique identifier"""
  goid: ID

  """The listen port configuration name"""
  name: String!

  """
  Whether this listen port configuration is enabled to listen for traffic on the specified port
  """
  enabled: Boolean!

  """
  Protocol (scheme). Possible values are:
  HTTP
  HTTPS
  HTTP2
  HTTP2 (Secure)
  FTP
  FTPS
  l7.raw.tcp
  SSH2
  """
  protocol: String!

  """
  The ListenPort's port number
  Note: If the listen port is using the SSH2 protocol, avoid using port 22, as
  it may conflict with the default SSH port 22 on Linux or Unix systems.
  """
  port: PositiveInt!

  """The name of the published service hardwired to the listen port"""
  hardwiredServiceName: String

  """Which Gateway services can be accessed through this listen port"""
  enabledFeatures: [ListenPortFeature!]!

  """The listen port tls settings"""
  tlsSettings: ListenPortTlsSettingsInput

  """The listen port properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ListenPortsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  listenPorts: [ListenPort]!
}

type ListenPortTlsSettings {
  """
  Specify whether the client must present a certificate to authenticate: NONE/OPTIONAL/REQUIRED
  """
  clientAuthentication: ListenPortClientAuth!

  """Keystore ID"""
  keystoreId: ID

  """Key alias configured for listen port"""
  keyAlias: String

  """TLS versions to be enabled for the listen port"""
  tlsVersions: [String!]!

  """Cipher suites that will be enabled on the SSL listen port"""
  cipherSuites: [String!]

  """Enforces cipher suites usage in the order of preference"""
  useCipherSuitesOrder: Boolean!
}

input ListenPortTlsSettingsInput {
  """
  Specify whether the client must present a certificate to authenticate: NONE/OPTIONAL/REQUIRED
  """
  clientAuthentication: ListenPortClientAuth!

  """Keystore ID"""
  keystoreId: ID

  """Key alias configured for listen port"""
  keyAlias: String

  """TLS versions to be enabled for the listen port"""
  tlsVersions: [String!]!

  """Cipher suites that will be enabled on the SSL listen port"""
  cipherSuites: [String!]

  """Enforces cipher suites usage in the order of preference"""
  useCipherSuitesOrder: Boolean!
}

input MembershipInput {
  name: String!
}

type MemberStrategy {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

input MemberStrategyInput {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

enum ModuleState {
  UPLOADED
  ACCEPTED
  REJECTED
  LOADED
  ERROR
}

enum ModuleStateSummary {
  LOADING
  LOADED
  ERROR
}

enum ModuleType {
  MODULAR_ASSERTION
  CUSTOM_ASSERTION
}

type Mutation {
  """Create or update policy fragments"""
  setPolicyFragments(input: [PolicyFragmentInput!]!): PolicyFragmentsPayload!

  """Delete policy fragments"""
  deletePolicyFragments(names: [String!]!): PolicyFragmentsPayload!

  """Create or update global policies"""
  setGlobalPolicies(input: [GlobalPolicyInput!]!): GlobalPoliciesPayload!

  """Delete global policies"""
  deleteGlobalPolicies(tags: [String!]!): GlobalPoliciesPayload!

  """Create or update web api services"""
  setWebApiServices(input: [WebApiServiceInput!]!): WebApiServicesPayload

  """Create or update Internal web api services"""
  setInternalWebApiServices(input: [WebApiServiceInput!]!): InternalWebApiServicesPayload

  """Delete existing web api services given their resolution paths"""
  deleteWebApiServices(resolutionPaths: [String!]!): WebApiServicesPayload

  """Delete existing Internal web api services given their resolution paths"""
  deleteInternalWebApiServices(resolutionPaths: [String!]!): InternalWebApiServicesPayload

  """Create or update soap services"""
  setSoapServices(input: [SoapServiceInput!]!): SoapServicesPayload

  """Create or update Internal soap services"""
  setInternalSoapServices(input: [SoapServiceInput!]!): InternalSoapServicesPayload

  """Delete existing soap services given their resolution details"""
  deleteSoapServices(resolvers: [SoapServiceResolverInput!]!): SoapServicesPayload

  """Delete existing Internal soap services given their resolution details"""
  deleteInternalSoapServices(resolvers: [SoapServiceResolverInput!]!): InternalSoapServicesPayload

  """Create or update Encapsulated Assertion Configurations"""
  setEncassConfigs(input: [EncassConfigInput!]!): EncassConfigsPayload

  """Delete existing Encapsulated Assertion Configurations"""
  deleteEncassConfigs(names: [String!]!): EncassConfigsPayload

  """
  Create or update existing cluster properties.  If a cluster property with the given name does not
  exist, one will be created, otherwise the existing one will be updated. This returns the list of
  entities created and/or updated
  """
  setClusterProperties(input: [ClusterPropertyInput!]!): ClusterPropertiesPayload!

  """Delete existing cluster properties"""
  deleteClusterProperties(names: [String!]!): ClusterPropertiesPayload!

  """
  Create or update trusted certificates.
  If a certificate with the same sha1 thumbprint already exist, it will be updated.
  """
  setTrustedCerts(input: [TrustedCertInput!]!): TrustedCertsPayload!

  """Delete an existing certificates"""
  deleteTrustedCerts(thumbprintSha1s: [String!]!): TrustedCertsPayload!

  """
  Create a JDBC connection.
  If a JDBC connection with the same name already exists, the creation will fail.
  NOTE: This is experimental method, likely to be removed or revised in future.
  """
  createJdbcConnection(input: JdbcConnectionInput!): JdbcConnectionPayload!

  """
  Update an existing JDBC connection.
  If no JDBC connection with the same name exist, the update will fail
  NOTE: This is experimental method, likely to be removed or revised in future.
  """
  updateJdbcConnection(input: JdbcConnectionPartialInput!): JdbcConnectionPayload!

  """
  Create or update JDBC connections.
  If JDBC connection with the same name exist, the JDBC connection will be updated.
  If no JDBC connection with the name exist, a new JDBC connection will be created.
  """
  setJdbcConnections(input: [JdbcConnectionInput!]!): JdbcConnectionsPayload!

  """Deletes JDBC connections."""
  deleteJdbcConnections(
    """The names of the JDBC connection to delete"""
    names: [String!]!
  ): JdbcConnectionsPayload

  """
  Create or update Cassandra connections.
  If Cassandra connection with the same name exist, the Cassandra connection will be updated.
  If no Cassandra connection with the name exist, a new Cassandra connection will be created.
  """
  setCassandraConnections(input: [CassandraConnectionInput!]!): CassandraConnectionsPayload!

  """Deletes Cassandra connections."""
  deleteCassandraConnections(
    """The names of the Cassandra connection to delete"""
    names: [String!]!
  ): CassandraConnectionsPayload!

  """
  Create or update JMS destinations.
  If JMS destination with the same name exist, the JMS destination will be updated.
  If no JMS destination with the name exist, a new JMS destination will be created.
  """
  setJmsDestinations(input: [JmsDestinationInput!]!): JmsDestinationsPayload!

  """Deletes JMS destinations."""
  deleteJmsDestinations(
    """The names of the JMS destination to delete"""
    names: [String!]!
  ): JmsDestinationsPayload

  """Create or Update multiple XML schemas"""
  setSchemas(input: [SchemaInput!]!): SchemasPayload

  """Delete multiple XML schemas"""
  deleteSchemas(systemIds: [String!]!): SchemasPayload

  """Create or Update multiple DTD resources"""
  setDtds(input: [DtdInput!]!): DtdsPayload

  """Delete multiple DTD resources"""
  deleteDtds(systemIds: [String!]!): DtdsPayload

  """Creates or updates one or more fips"""
  setFips(input: [FipInput!]!): FipsPayload

  """Creates or updates one or more ldaps"""
  setLdaps(input: [LdapInput!]!): LdapsPayload

  """Deletes one or more existing fips"""
  deleteFips(names: [String!]!): FipsPayload

  """Deletes one or more existing ldaps"""
  deleteLdaps(names: [String!]!): LdapsPayload

  """Creates or updates one or more internal users"""
  setInternalUsers(input: [InternalUserInput!]!): InternalUsersPayload

  """Creates or updates one or more internal groups"""
  setInternalGroups(input: [InternalGroupInput!]!): InternalGroupsPayload

  """Deletes one or more existing internal users"""
  deleteInternalUsers(logins: [String!]!): InternalUsersPayload

  """Deletes one or more existing internal groups"""
  deleteInternalGroups(names: [String!]!): InternalGroupsPayload

  """Creates or updates one or more fip users"""
  setFipUsers(input: [FipUserInput!]!): FipUsersPayload

  """Creates or updates one or more fip groups"""
  setFipGroups(input: [FipGroupInput!]!): FipGroupsPayload

  """Deletes one or more existing fip users"""
  deleteFipUsers(providerName: String!, names: [String!]!): FipUsersPayload

  """Deletes one or more existing fip groups"""
  deleteFipGroups(providerName: String!, names: [String!]!): FipGroupsPayload

  """Creates or updates one or more secrets"""
  setSecrets(input: [SecretInput!]!): SecretsPayload

  """Creates or updates one or more keys"""
  setKeys(input: [KeyInput!]!): KeysPayload

  """Deletes one or more existing secrets"""
  deleteSecrets(names: [String!]!): SecretsPayload

  """Deletes one or more existing keys"""
  deleteKeys(aliases: [String!]!): KeysPayload

  """
  Sets Server module files. Updating the existing server module file is unsupported.
  """
  setServerModuleFiles(input: [ServerModuleFileInput!]!): ServerModuleFilesPayload

  """Deletes Server module files."""
  deleteServerModuleFiles(
    """The names of the Server module file to delete"""
    names: [String!]!
  ): ServerModuleFilesPayload

  """Creates or updates one or more scheduled tasks"""
  setScheduledTasks(input: [ScheduledTaskInput!]!): ScheduledTasksPayload!

  """Creates or updates one or more background task policies"""
  setBackgroundTaskPolicies(input: [BackgroundTaskPolicyInput!]!): BackgroundTaskPoliciesPayload!

  """Deletes one or more existing scheduled tasks"""
  deleteScheduledTasks(names: [String!]!): ScheduledTasksPayload!

  """Deletes an existing background task policy"""
  deleteBackgroundTaskPolicies(names: [String!]!): BackgroundTaskPoliciesPayload!

  """
  Create or update existing email listeners.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created.
  """
  setEmailListeners(input: [EmailListenerInput!]!): EmailListenersPayload!

  """Delete existing email listeners. Match is carried by name."""
  deleteEmailListeners(names: [String!]!): EmailListenersPayload!

  """
  Create or update Listen Ports.
  If Listen Port with the same name exist, the Listen Port will be updated.
  If no Listen Port with the name exist, a new Listen Port will be created.
  """
  setListenPorts(input: [ListenPortInput!]!): ListenPortsPayload!

  """Delete existing listen ports. Match is carried by name."""
  deleteListenPorts(names: [String!]!): ListenPortsPayload!

  """
  Create or update existing active connector.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created.
  """
  setActiveConnectors(input: [ActiveConnectorInput!]!): ActiveConnectorsPayload!

  """Delete existing active connector. Match is carried by name."""
  deleteActiveConnectors(names: [String!]!): ActiveConnectorsPayload!

  """
  Create or update existing siteminder configurations.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created
  """
  setSMConfigs(input: [SMConfigInput!]!): SMConfigsPayload!

  """Delete existing siteminder configurations. Match is carried by name"""
  deleteSMConfigs(names: [String!]!): SMConfigsPayload!
}

"""A String scalar that must be a non empty value"""
scalar NonEmptyString

"""An Integer that MUST be greater than or equal to zero"""
scalar NonNegativeInt

type PasswdStrategy {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

input PasswdStrategyInput {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

"""Wrapper for the policy XML and the dependencies they include"""
type Policy {
  """The policy XML"""
  xml: String!

  """Entities that are directly referred to inside the policy XML"""
  directDependencies: PolicyDependency

  """
  Entities that are directly referred to inside the policy XML in addition to
  ones in policy dependencies. More than second level, this keep going as deep
  as needed until no dependencies are found
  """
  allDependencies: PolicyDependency
}

"""
Policy Dependency contains all dependencies that may be referred to from the policy XML this is associated with
"""
type PolicyDependency {
  """Policy Fragments"""
  policyFragments: [PolicyFragment]

  """Cluster properties"""
  clusterProperties: [ClusterProperty]

  """Trusted certificates"""
  trustedCerts: [Certificate]

  """Encass Configs"""
  encassConfigs: [EncassConfig]

  """JDBC connections"""
  jdbcConnections: [JdbcConnection]

  """Cassandra connections"""
  cassandraConnections: [CassandraConnection]

  """JMS destinations"""
  jmsDestinations: [JmsDestination]

  """Schemas in global resources"""
  schemas: [Schema]

  """DTDs in global resources"""
  dtds: [Dtd]

  """Federated identity provider configurations"""
  fips: [Fip]

  """Ldap identity provider configurations"""
  ldaps: [Ldap]

  """Internal idp users"""
  internalUsers: [InternalUser]

  """Internal idp groups"""
  internalGroups: [InternalGroup]

  """Federated identity provider users"""
  fipUsers: [FipUser]

  """Federated identity provider groups"""
  fipGroups: [FipGroup]
  secrets: [Secret]
  keys: [Key]

  """Server module files (signed modular or custom assertions)"""
  serverModuleFiles: [ServerModuleFile]

  """Email Listeners"""
  emailListeners: [EmailListener]

  """Listen Ports"""
  listenPorts: [ListenPort]

  """Active Connectors (SFTP, MQ Native, Kafka)"""
  activeConnectors: [ActiveConnector]

  """Siteminder Configurations"""
  smConfigs: [SMConfig]
}

"""A policy fragment that can be included in another policy"""
type PolicyFragment {
  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """The name of the policy (policies are unique by name)"""
  name: String!

  """The folder path to the policy"""
  folderPath: String!

  """The actual policy and dependencies"""
  policy: Policy!
  soap: Boolean

  """The configuration checksum"""
  checksum: String!
}

input PolicyFragmentInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the policy. Policies are unique by name."""
  name: String!

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """The policy"""
  policy: PolicyInput!
  soap: Boolean = false

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type PolicyFragmentsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  policyFragments: [PolicyFragment]!
}

input PolicyInput {
  """The policy xml"""
  xml: String!
}

enum PolicyUsageType {
  """Do not perform revocation check"""
  NONE

  """Use the default revocation check policy"""
  USE_DEFAULT

  """Use the specified revocation check policy"""
  SPECIFIED
}

"""An Integer that MUST be greater than zero"""
scalar PositiveInt

interface PublishedService {
  """The name of the published service"""
  name: String!

  """The resolution path for published service"""
  resolutionPath: String

  """The folder path for published service"""
  folderPath: String!

  """Which HTTP methods are permitted for incoming requests"""
  methodsAllowed: [HttpMethod!]!

  """Whether published service is enabled"""
  enabled: Boolean!
}

type Query {
  """Get all policy fragments"""
  policyFragments: [PolicyFragment!]!

  """Get policy fragment by name"""
  policyFragmentByName(name: String!): PolicyFragment

  """Get policy fragments inside a folder"""
  policyFragmentsByFolderPath(folderPath: String!): [PolicyFragment!]!

  """Get policy fragment by goid"""
  policyFragmentByGoid(goid: ID!): PolicyFragment

  """Get policy fragment by guid"""
  policyFragmentByGuid(guid: ID!): PolicyFragment

  """Get all global policies"""
  globalPolicies: [GlobalPolicy!]!

  """Get global policy by tag"""
  globalPolicyByTag(tag: String!): GlobalPolicy

  """Get global policies inside a folder"""
  globalPoliciesByFolderPath(folderPath: String!): [GlobalPolicy!]!

  """Get all webApi services"""
  webApiServices: [WebApiService]!
  internalWebApiServices: [InternalWebApiService]!

  """Get webApi services by name"""
  webApiServicesByName(name: String!): [WebApiService!]!

  """Get webApi service by name. Returns none if more than one are found."""
  webApiServiceByName(name: String!): WebApiService

  """Get Internal webApi Service by name"""
  internalWebApiServiceByName(name: String!): InternalWebApiService

  """Get webApi services by resolutionPath"""
  webApiServicesByResolutionPath(resolutionPath: String!): [WebApiService!]!

  """
  Get webApi service by resolutionPath. Returns none if more than one are found.
  """
  webApiServiceByResolutionPath(resolutionPath: String!): WebApiService

  """Get Internal webApi Services by resolutionPath"""
  internalWebApiServiceByResolutionPath(resolutionPath: String!): InternalWebApiService

  """Get webApi services inside a folder"""
  webApiServicesByFolderPath(folderPath: String!): [WebApiService]!

  """Get Internal webApi services inside a folder"""
  internalWebApiServicesByFolderPath(folderPath: String!): [InternalWebApiService]!

  """Get webApi services by goid"""
  webApiServiceByGoid(goid: ID!): WebApiService

  """Get all soap services"""
  soapServices: [SoapService]!

  """Get all Internal soap services"""
  internalSoapServices: [InternalSoapService]!

  """Get soap services by name"""
  soapServicesByName(name: String!): [SoapService]!

  """Get soap service by name. Returns none if more than one are found."""
  soapServiceByName(name: String!): SoapService

  """
  Get Internal soap service by name. Returns none if more than one are found.
  """
  internalSoapServiceByName(name: String!): InternalSoapService

  """Get soap services inside a folder"""
  soapServicesByFolderPath(folderPath: String!): [SoapService]!

  """Get Internal soap services inside a folder"""
  internalSoapServicesByFolderPath(folderPath: String!): [InternalSoapService]!

  """Get soap service by goid"""
  soapServiceByGoid(goid: ID!): SoapService

  """Get soap service by resolver"""
  soapServiceByResolver(resolver: SoapServiceResolverInput!): SoapService

  """Get all Encapsulated Assertion Configurations"""
  encassConfigs: [EncassConfig!]!

  """Get all Encapsulated Assertion Configurations by folder path"""
  encassConfigsByFolderPath(folderPath: String!): [EncassConfig!]!

  """Get Encapsulated Assertion Configuration by name"""
  encassConfigByName(name: String!): EncassConfig

  """Get Encapsulated Assertion Configuration by goid"""
  encassConfigByGoid(goid: ID!): EncassConfig

  """Get Encapsulated Assertion Configuration by guid"""
  encassConfigByGuid(guid: ID!): EncassConfig

  """Get all cluster properties"""
  clusterProperties: [ClusterProperty!]!

  """Get the cluster property with the given name"""
  clusterPropertyByName(name: String!): ClusterProperty

  """Retrieves all trusted certificates"""
  trustedCerts: [Certificate!]!

  """Retrieves a list of trusted certificates with the matching subject dn"""
  trustedCertsByDn(subjectDn: String!): [Certificate]!

  """The trusted certificate associated with this unique thumbprint"""
  trustedCertByThumbprint(thumbprintSha1: String!): Certificate

  """Get all JDBC Connections"""
  jdbcConnections: [JdbcConnection!]!

  """Get JDBC Connection by name"""
  jdbcConnectionByName(name: String!): JdbcConnection

  """Get JDBC Connection by goid"""
  jdbcConnectionByGoid(goid: ID!): JdbcConnection

  """Get all Cassandra Connections"""
  cassandraConnections: [CassandraConnection!]!

  """Get Cassandra Connection by name"""
  cassandraConnectionByName(name: String!): CassandraConnection

  """Get Cassandra Connection by goid"""
  cassandraConnectionByGoid(goid: ID!): CassandraConnection

  """Get all JMS Destinations"""
  jmsDestinations: [JmsDestination!]!

  """Get JMS Destination by name"""
  jmsDestinationByName(name: String!): JmsDestination

  """Get JMS Destination by goid"""
  jmsDestinationByGoid(goid: ID!): JmsDestination

  """Get xml schemas configured on this gateway"""
  schemas: [Schema!]!

  """The schema given its system id"""
  schemaBySystemId(systemId: String!): Schema

  """The dtds configured on this gateway"""
  dtds: [Dtd!]!

  """The dtd given its system id"""
  dtdBySystemId(systemId: String!): Dtd

  """Get internal schemas, for reference only"""
  internalSchemas: [Schema!]!

  """Get internal dtds, for reference only"""
  internalDtds: [Dtd!]!

  """Get all internal users"""
  internalUsers: [InternalUser!]!

  """Get all internal groups"""
  internalGroups: [InternalGroup!]!

  """Get internal user by login"""
  internalUserByLogin(login: String!): InternalUser

  """Get internal group by name"""
  internalGroupByName(name: String!): InternalGroup

  """Get internal users and groups"""
  searchInternal(filter: IdpFilter!): InternalSearchResult!

  """Get all fips configurations"""
  fips: [Fip!]!

  """Get all fip users"""
  fipUsers: [FipUser!]!

  """Get all fip groups"""
  fipGroups: [FipGroup!]!

  """Get fip configuration by name"""
  fipByName(name: String!): Fip

  """Get fip user by name"""
  fipUserByName(providerName: String!, name: String!): FipUser

  """Get fip group by name"""
  fipGroupByName(providerName: String!, name: String!): FipGroup
  searchFip(filter: IdpFilter!): FipSearchResult!

  """Get all ldap configurations"""
  ldaps: [Ldap!]!

  """Get ldap configuration by name"""
  ldapByName(name: String!): Ldap

  """Retrieves all secrets"""
  secrets: [Secret!]!

  """Retrieves all keys"""
  keys: [Key!]!

  """Retrieves a secret by name"""
  secretByName(name: String!): Secret

  """Retrieves a key by name"""
  keyByAlias(alias: String!): Key

  """Get all Server module files"""
  serverModuleFiles: [ServerModuleFile!]!

  """Get Server module file by name"""
  serverModuleFileByName(name: String!): ServerModuleFile

  """Retrieves all scheduled tasks"""
  scheduledTasks: [ScheduledTask!]!

  """Retrieves all background task policies"""
  backgroundTaskPolicies: [BackgroundTaskPolicy!]!

  """Retrieves a scheduled task by name"""
  scheduledTaskByName(name: String!): ScheduledTask

  """Retrieves a background task policy by name"""
  backgroundTaskPolicyByName(name: String!): BackgroundTaskPolicy

  """Retrieves background task policies by folder path"""
  backgroundTaskPoliciesByFolderPath(folderPath: String!): [BackgroundTaskPolicy!]!

  """Get all email listeners"""
  emailListeners: [EmailListener!]!

  """Get the email listener by name"""
  emailListenerByName(name: String!): EmailListener

  """Get all listen ports"""
  listenPorts: [ListenPort!]!

  """Get the listen port by name"""
  listenPortByName(name: String!): ListenPort

  """Get the listen ports by protocol"""
  listenPortsByProtocol(protocol: String!): [ListenPort!]!

  """Get all active connectors"""
  activeConnectors: [ActiveConnector!]!

  """Get the active connector by name"""
  activeConnectorByName(name: String!): ActiveConnector

  """Get the active connectors by type"""
  activeConnectorsByType(connectorType: ActiveConnectorType!): [ActiveConnector!]!

  """Get all siteminder configurations"""
  smConfigs: [SMConfig!]!

  """Get the siteminder configuration by name"""
  smConfigByName(name: String!): SMConfig
}

"""A revocation check policy for certificates"""
type RevocationCheckPolicy {
  """The goid for this revocation check policy"""
  goid: ID!

  """The name for this revocation check policy"""
  name: String!
}

"""A scheduled task"""
type ScheduledTask {
  """The name of the scheduled task"""
  name: String!

  """The name of the policy for scheduled task"""
  policyName: String!

  """Scheduled task type"""
  jobType: JobType!

  """The cron job expression"""
  cronExpression: String

  """Whether to execute on single node"""
  executeOnSingleNode: Boolean!

  """Whether to execute the RECURRING task now?"""
  executeOnCreation: Boolean!

  """Execution date of a ONE_TIME task"""
  executionDate: DateTime

  """The scheduled task status"""
  status: JobStatus!
  runAsUser: String
  runAsUserProviderName: String

  """The internal entity unique identifier"""
  goid: ID!

  """The configuration checksum"""
  checksum: String!
}

input ScheduledTaskInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the scheduled task"""
  name: String!

  """The name of the policy for scheduled task"""
  policyName: String!
  jobType: JobType!

  """The cron job expression"""
  cronExpression: String

  """Whether to execute on single node"""
  executeOnSingleNode: Boolean!

  """Whether to execute the RECURRING task now?"""
  executeOnCreation: Boolean!

  """Specify a future execution date for a ONE_TIME task"""
  executionDate: DateTime

  """The scheduled task status"""
  status: JobStatus = SCHEDULED
  runAsUser: String
  runAsUserProviderName: String

  """The configuration checksum"""
  checksum: String
}

type ScheduledTasksPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  scheduledTasks: [ScheduledTask]!
}

"""
An XML Schema which can be referred to in policy, for example in the validate xml schema assertion
"""
type Schema {
  """Internal goid for this schema"""
  goid: ID!

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The target namespace in the xml schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!

  """The configuration checksum"""
  checksum: String!
}

input SchemaInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The target namespace in the XML schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type SchemasPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  schemas: [Schema]!
}

"""
These secrets are used by gateway policies also for example by jdbc connection configurations
"""
type Secret {
  """
  Identify the password being stored. You may use letters, numbers, dashes, and underscores.
  Names that contain spaces or periods are valid, but the resulting stored
  password cannot be referenced via context variable.
  Names that contain @ or $ are valid, but the resulting stored password cannot be referenced via context variable.
  """
  name: String!

  """Password or PEM Private Key"""
  secretType: SecretType!

  """The goid for the Secret"""
  goid: ID!

  """The configuration checksum"""
  checksum: String!

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can decrypt these values at command line
  using this command:
  > echo <secret> | openssl enc -d -aes-256-cbc -md sha256 -pass pass:<passphrase> -a
  """
  secret: String!

  """Description of the password. This is optional"""
  description: String
}

input SecretInput {
  """
  Identify the password being stored. You may use letters, numbers, dashes, and underscores.
  Names that contain spaces or periods are valid, but the resulting stored
  password cannot be referenced via context variable.
  Names that contain @ or $ are valid, but the resulting stored password cannot be referenced via context variable.
  """
  name: String!

  """Password or PEM Private Key"""
  secretType: SecretType!

  """The goid for the Secret"""
  goid: ID

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can create this value at command line:
  > echo -n "<clear text secret>" | openssl enc -aes-256-cbc -md sha256 -pass pass:<password> -a
  """
  secret: String!

  """Description of the password. This is optional"""
  description: String
}

type SecretsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  secrets: [Secret]!
}

enum SecretType {
  """Stored password for example used in the jdbc connection"""
  PASSWORD

  """Secure pem key for example used in the route via ssh assertion"""
  PEM_PRIVATE_KEY
}

"""A Server module file"""
type ServerModuleFile {
  """The goid for the Server module file"""
  goid: ID!

  """The Server module name"""
  name: String!

  """The Server module type"""
  moduleType: ModuleType!

  """The Server module SHA256 digest value"""
  moduleSha256: String!

  """The Server module signature"""
  signature: String!

  """The base64 encoded signer certificate"""
  signerCertBase64: String!

  """The Server module file properties"""
  properties: [EntityProperty!]!

  """The Server module file state per node in the cluster"""
  moduleStates: [ServerModuleFileState!]!
  moduleStateSummary: ServerModuleFileStateSummary!

  """
  The dummy field, is used to get the Server module file content in separate part
  """
  filePartName: String!

  """The configuration checksum of this Server module file"""
  checksum: String!
}

input ServerModuleFileInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Server module name"""
  name: String!

  """The Server module type"""
  moduleType: ModuleType

  """The Server module SHA256 digest value"""
  moduleSha256: String

  """The Server module signature"""
  signature: String

  """The base64 encoded signer certificate"""
  signerCertBase64: String

  """The Server module file properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ServerModuleFilesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created Server module files."""
  serverModuleFiles: [ServerModuleFile]!
}

type ServerModuleFileState {
  nodeId: String!
  nodeName: String!
  state: ModuleState!
  description: String
}

type ServerModuleFileStateSummary {
  state: ModuleStateSummary!
  description: String
}

type SMConfig {
  """The goid for the CA SSO connection"""
  goid: ID!

  """Name of the CA SSO configuration"""
  name: String!

  """
  Indicates whether the specified configuration is currently enabled or disabled
  """
  enabled: Boolean!

  """Name of the host registered with the CA SSO Policy Server"""
  agentHost: String!

  """
  The IP address of the CA SSO agent. This field is required if the Check IP check box is selected
  """
  agentIP: String!

  """CA SSO Policy Server host configuration used by the agent"""
  agentHostConfig: String!

  """
  CA SSO shared secret used by the agent to establish communication with the Policy Server
  """
  agentSecret: String!

  """
  Choose the FIPS mode supported by the CA SSO Policy Server. The available values are: COMPAT(default)/MIGRATE/ONLY
  """
  cryptoMode: SMCryptoMode!

  """
  The CA SSO Policy Server compare the client IP against the address stored in the SSO Token
  """
  ipCheckEnabled: Boolean!

  """
  Whether to update the SSO Token after successful authentication/authorization
  """
  updateSSOToken: Boolean!

  """
  The percentage of servers within a cluster that must be available for Policy Server requests
  """
  clusterFailoverThreshold: PositiveInt!
  nonClusterFailover: Boolean!

  """User name of the CA SSO administrator"""
  username: String!

  """The secure password reference"""
  securePasswordName: String!

  """The Siteminder configuration properties"""
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

input SMConfigInput {
  """The goid for the CA SSO connection"""
  goid: ID

  """Name of the CA SSO configuration"""
  name: String!

  """
  Indicates whether the specified configuration is currently enabled or disabled
  """
  enabled: Boolean!

  """Name of the host registered with the CA SSO Policy Server"""
  agentHost: String!

  """
  The IP address of the CA SSO agent. This field is required if the Check IP check box is selected
  """
  agentIP: String!

  """CA SSO Policy Server host configuration used by the agent"""
  agentHostConfig: String!

  """
  CA SSO shared secret used by the agent to establish communication with the Policy Server
  """
  agentSecret: String!

  """
  Choose the FIPS mode supported by the CA SSO Policy Server. The available values are: COMPAT(default)/MIGRATE/ONLY
  """
  cryptoMode: SMCryptoMode!

  """
  The CA SSO Policy Server compare the client IP against the address stored in the SSO Token
  """
  ipCheckEnabled: Boolean!

  """
  Whether to update the SSO Token after successful authentication/authorization
  """
  updateSSOToken: Boolean!

  """
  The percentage of servers within a cluster that must be available for Policy Server requests
  """
  clusterFailoverThreshold: PositiveInt!
  nonClusterFailover: Boolean!

  """User name of the CA SSO administrator"""
  username: String!

  """The secure password reference"""
  securePasswordName: String!

  """The Siteminder configuration properties"""
  properties: [EntityPropertyInput!]

  """The configuration checksum"""
  checksum: String
}

type SMConfigsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  smConfigs: [SMConfig]!
}

enum SMCryptoMode {
  COMPAT
  MIGRATE
  FIPS
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
type SoapResolvers {
  """The soap actions referred to in the wsdl"""
  soapActions: [String!]!

  """
  Base uri from the wsdl of the service. This is used for service resolution
  """
  baseUri: String

  """The resolution path to the service if not default /ssg/soap"""
  resolutionPath: String
}

"""A Soap service published on the Layer7 Gateway"""
type SoapService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String

  """The folder path to the service"""
  folderPath: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """Soap service resolvers"""
  resolvers: SoapResolvers!

  """Which SOAP version"""
  soapVersion: SoapVersion!
  wssProcessingEnabled: Boolean!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed if not just POST"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

input SoapServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the service"""
  name: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """The resolution path of the service"""
  resolutionPath: String

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default true)"""
  enabled: Boolean = true

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!

  """Which SOAP version"""
  soapVersion: SoapVersion = UNKNOWN

  """
  Whether or not the gateway should process incoming ws-security soap headers
  """
  wssProcessingEnabled: Boolean!
  tracingEnabled: Boolean = false

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean = false
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
input SoapServiceResolverInput {
  """
  One of the SoapAction of the service to resolved. This must be specified along with a base ns from the WSDL
  """
  soapAction: String

  """
  Base uri from the wsdl of the service. Use this alongside the soapaction
  property to resolve a soap service without resolutionUri
  """
  baseUri: String

  """
  The resolution path of the service if that is how the soap service is resolved
  """
  resolutionPath: String
}

type SoapServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  soapServices: [SoapService]!
}

enum SoapVersion {
  SOAP_1_1
  SOAP_1_2
  UNKNOWN
}

"""Input sent with createTrustedCert mutation"""
input TrustedCertInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the trusted certificate"""
  name: String!

  """The base 64 encoded string of the certificate"""
  certBase64: String!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """What the certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """
  The name of revocation policy.  Required if revocationCheckPolicyType is PolicyUsageType.SPECIFIED
  """
  revocationCheckPolicyName: String

  """
  The Subject DN of this certificate. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """
  The start date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notBefore: String

  """
  the end date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notAfter: String

  """
  The sha1 thumbprint of the certificate. (Note that, this field has no effect on the mutation)
  """
  thumbprintSha1: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type TrustedCertsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  trustedCerts: [Certificate]!
}

"""Defines what a certificate is trusted for"""
enum TrustedForType {
  """Is trusted as an SSL server cert"""
  SSL

  """Is trusted as a CA that signs SSL server certs"""
  SIGNING_SERVER_CERTS

  """Is trusted as a CA that signs SSL client certs"""
  SIGNING_CLIENT_CERTS

  """Is trusted to sign SAML tokens"""
  SAML_ISSUER

  """Is trusted as a SAML attesting entity"""
  SAML_ATTESTING_ENTITY
}

type UserMapping {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategy!
}

input UserMappingInput {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategyInput!
}

"""A Web API service published on the Layer7 Gateway"""
type WebApiService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String!

  """The folder path to the service"""
  folderPath: String!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!
  properties: [EntityProperty!]

  """The configuration checksum"""
  checksum: String!
}

input WebApiServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: NonEmptyString!

  """The name of the service"""
  name: String!

  """The resolution path of the service"""
  resolutionPath: String!

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default to true)"""
  enabled: Boolean = true

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean = false
  wssProcessingEnabled: Boolean = false
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type WebApiServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  webApiServices: [WebApiService]!
}

