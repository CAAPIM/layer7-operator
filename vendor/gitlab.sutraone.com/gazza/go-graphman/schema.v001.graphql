"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type BackgroundTaskPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  backgroundTaskPolicies: [BackgroundTaskPolicy]!
}

"""
A background task policy that is associated with a scheduled task to be run
"""
type BackgroundTaskPolicy {
  name: String!
  folderPath: String!
  guid: ID!
  goid: ID!
  policy: Policy!
  checksum: String!
}

input BackgroundTaskPolicyInput {
  """The internal entity unique identifier"""
  goid: ID
  name: String!
  guid: ID
  folderPath: String!
  policy: PolicyInput!
  checksum: String
}

"""A Cassandra Connection"""
type CassandraConnection {
  """The goid for the Cassandra Connection"""
  goid: ID!

  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String!

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The username"""
  username: String

  """The secure password reference."""
  securePassword: String

  """The Cassandra connection compression type"""
  compression: String!

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra connection properties"""
  properties: [EntityProperty!]!

  """The configuration checksum of this Cassandra connection"""
  checksum: String!
}

input CassandraConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The username"""
  username: String

  """The secure password reference."""
  securePassword: String

  """The Cassandra connection compression type"""
  compression: String

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra connection properties"""
  properties: [EntityPropertyInput!]! = []

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input CassandraConnectionPartialInput {
  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String

  """The Cassandra connection points"""
  contactPoints: [String!]

  """The Cassandra server port"""
  port: PositiveInt

  """The username"""
  username: String

  """The secure password reference."""
  securePassword: String

  """The Cassandra connection compression type"""
  compression: String

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean

  """The Cassandra connection properties"""
  properties: [EntityPropertyInput!]
}

type CassandraConnectionPayload implements EntityMutationPayload {
  status: EntityMutationStatus!

  """The mutated Cassandra connection."""
  cassandraConnection: CassandraConnection
}

type CassandraConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!

  """The mutated Cassandra connections."""
  cassandraConnections: [CassandraConnection]!
}

"""An certificate that is trusted by the Gateway"""
type Certificate {
  """The goid for this certificate"""
  goid: ID!

  """The name"""
  name: String!

  """The Subject DN of this certificate"""
  subjectDn: String!

  """The start date of the validity period"""
  notBefore: DateTime!

  """the end date of the validity period"""
  notAfter: DateTime!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """The certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The base 64 encoded string of this certificate"""
  certBase64: String!

  """The sha1 thumbprint of the certificate"""
  thumbprintSha1: String!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """The specified revocation policy"""
  revocationCheckPolicy: RevocationCheckPolicy

  """The configuration checksum of this trusted certificate"""
  checksum: String!
}

type ClusterPropertiesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  clusterProperties: [ClusterProperty]!
}

"""Cluster properties are used to set global properties"""
type ClusterProperty {
  """The goid for the cluster property"""
  goid: ID!

  """The cluster property name"""
  name: String!

  """The cluster property value"""
  value: String!

  """The cluster property description"""
  description: String

  """Whether this is a hidden property"""
  hiddenProperty: Boolean!

  """The configuration checksum of this cluster prop"""
  checksum: String!
}

"""The inputs sent with the setClusterProperty Mutation"""
input ClusterPropertyInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the cluster property"""
  name: String!

  """The value of the cluster property to set"""
  value: String!

  """The cluster property description"""
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input CreateFipGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this group is defined in """
  providerName: String!
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input CreateFipInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [FipCertInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String
}

input CreateFipUserInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this user is defined as part of """
  providerName: String!

  """
  The list of fip group names that this user is member of. If you pass empty
  array, will reset memberships. If absent, does not affect memberships for current user.
  """
  memberOf: [MembershipInput!]
  login: String
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  checksum: String!
}

input CreateInternalGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input CreateInternalUserInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """
  The list of internal group names that this user is member of. If you pass
  empty array, will reset memberships. If absent, does not affect memberships
  for current users.
  """
  memberOf: [MembershipInput!]
  login: String!

  """
  You can either pass in the hashed password which comes back in queries or the raw passwd directly
  """
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input CreateLdapInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID!
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMappingInput!]!
  groupMappings: [GroupMappingInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String!
}

enum DataType {
  STRING
  CERTIFICATE
  INTEGER
  DECIMAL
  FLOAT
  ELEMENT
  BOOLEAN
  BINARY
  DATE_TIME
  MESSAGE
  BLOB
  CLOB
  UNKNOWN
}

"""
An RFC-3339 compliant date time scalar that accepts string values like `1996-12-19T16:39:57-08:00`
"""
scalar DateTime

type DeleteFipGroupPayload {
  deleted: Boolean!
}

type DeleteFipUserPayload {
  deleted: Boolean!
}

type DeleteIdpPayload {
  deleted: Boolean!
}

type DeleteInternalGroupPayload {
  deleted: Boolean!
}

type DeleteInternalUserPayload {
  deleted: Boolean!
}

"""A Document Type Definition (DTD) which can be referred to in policy"""
type Dtd {
  """Internal goid for this DTD"""
  goid: ID!

  """
  A reference to the DTD. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The public id for the DTD"""
  publicId: String

  """An optional description"""
  description: String

  """The content of DTD itself"""
  content: String!

  """The configuration checksum"""
  checksum: String!
}

input DtdInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the dtd. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The public id for the dtd"""
  publicId: String

  """An optional description"""
  description: String

  """The actual dtd itself"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type DtdPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  dtd: Dtd!
}

type DtdsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  dtds: [Dtd]!
}

"""The description of an input argument for an encapsulated assertion"""
type EncassArg {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: Boolean

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""
The description of an input argument for an encapsulated assertion for use when
creating or updating an existing encass config
"""
input EncassArgInput {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: String

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""An Encapsulated Assertion Configuration"""
type EncassConfig {
  """The name of the encass config"""
  name: String!

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArg]

  """the output descriptions"""
  encassResults: [EncassResult]

  """The goid for this encass config"""
  goid: ID!

  """The guid for this encass config"""
  guid: ID!

  """The configuration checksum of this encass"""
  checksum: String!
}

"""
The description of a new encapsulated assertion configuration being created
"""
input EncassConfigInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The guid for this encass config, can be omitted and a new one is assigned
  """
  guid: ID

  """The name of the encass config"""
  name: String!

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArgInput]

  """the output descriptions"""
  encassResults: [EncassResultInput]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""
The description of an encapsulated assertion configuration being updated
"""
input EncassConfigPartialInput {
  """The name of the encass config"""
  name: String

  """The policy it points to and its dependencies"""
  policyName: String

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArgInput]

  """the output descriptions"""
  encassResults: [EncassResultInput]
}

type EncassConfigPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  encassConfig: EncassConfig!
}

type EncassConfigsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  encassConfigs: [EncassConfig]!
}

"""The description of an output from the encapsulated assertion"""
type EncassResult {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

"""
The description of an output from the encapsulated assertion for use when creating or updating an existing encass config
"""
input EncassResultInput {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

interface EntityMutationPayload {
  status: EntityMutationStatus!
}

interface EntityMutationsPayload {
  status: [EntityMutationStatus!]!
}

enum EntityMutationStatus {
  NONE
  CREATED
  UPDATED
  DELETED
}

"""An Entity Property"""
type EntityProperty {
  """The name of property"""
  name: String!

  """The value of the property"""
  value: String!
}

input EntityPropertyInput {
  name: String!
  value: String!
}

"""A Federated Identity Provider"""
type Fip {
  name: String!
  goid: ID!
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [Certificate!]!
  checksum: String!
}

input FipCertInput {
  """
  The thumbprint of the cert to use as trust for a federated identity provider
  """
  thumbprintSha1: String!
}

""" A group defined in a federated identity provider"""
type FipGroup {
  name: String!
  goid: ID!

  """ The name of the FiP this group is defined in """
  providerName: String!
  description: String

  """ Fip users that member of this group """
  members: [FipUser!]!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
}

""" A user defined in a federated identity provider """
type FipUser {
  name: String!
  goid: ID!

  """ The name of the FiP this user is defined as part of """
  providerName: String!

  """ The list of Fip groups this user belongs to """
  memberOf: [FipGroup!]!
  login: String
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  checksum: String!
}

type GlobalPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  globalPolicies: [GlobalPolicy]!
}

"""A Global policy"""
type GlobalPolicy {
  """The name of the policy (policies are unique by name)"""
  name: String!

  """The folder path where this policy is located"""
  folderPath: String!

  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The actual policy and dependencies"""
  policy: Policy!

  """The configuration checksum"""
  checksum: String!
}

input GlobalPolicyInput {
  """The name of the policy. Policies are unique by name."""
  name: String!

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The goid for this policy"""
  goid: ID

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The policy"""
  policy: PolicyInput!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""
enum UserCertificateUseType {
   NONE
   INDEX
   INDEX_CUSTOM
   SEARCH
}
"""
type GroupMapping {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategy!
}

input GroupMappingInput {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategyInput!
}

"""Support Http methods for Web API Service"""
enum HttpMethod {
  DELETE
  HEAD
  GET
  POST
  PUT
  OPTIONS
  PATCH
  OTHER
}

""" Indicate how to search for group or user. Provide either a name pattern, a subject dn and or a goid. 
"""
input IdpFilter {
  """ The name of the FiP provider, or 'Internal' """
  providerName: String!

  """
  Finds users and groups whose name matches the specified pattern. May include wildcard such as * character
  """
  namePattern: String

  """ SubjectDN of a FIP user """
  subjectDn: String

  """ Get entity by goid """
  goid: ID
}

type IdpSearchResult {
  internalUsers: [InternalUser!]!
  internalGroups: [InternalGroup!]!
  fipUsers: [FipUser!]!
  fipGroups: [FipGroup!]!
}

""" A group of users defined in the internal identity provider """
type InternalGroup {
  name: String!
  goid: ID!
  description: String

  """ The list of internal users that are part of this group """
  members: [InternalUser!]!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
}

""" A user in the internal identity provider """
type InternalUser {
  name: String!
  goid: ID!

  """ List of groups this is member of """
  memberOf: [InternalGroup!]!
  login: String

  """The hashed password of the user if defined"""
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  enabled: Boolean!
  checksum: String!
}

"""A JDBC Connection"""
type JdbcConnection {
  """The goid for the JDBC Connection"""
  goid: ID!

  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean!

  """The username"""
  username: String!

  """The password or the secure password reference."""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt!

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt!

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityProperty!]!

  """The configuration checksum of this JDBC connection"""
  checksum: String!
}

input JdbcConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean! = true

  """The username"""
  username: String!

  """The password or the secured password reference"""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt! = 3

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt! = 15

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityPropertyInput!]! = []

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input JdbcConnectionPartialInput {
  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String

  """The JDBC url"""
  jdbcUrl: String

  """Whether this JDBC connection is enabled"""
  enabled: Boolean

  """The username"""
  username: String

  """The password or the secured password reference"""
  password: String

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt

  """
  The JDBC connection properties excluding 'user' and 'password'.  When specified, will replace all existing properties
  """
  properties: [EntityPropertyInput!]
}

type JdbcConnectionPayload implements EntityMutationPayload {
  status: EntityMutationStatus!

  """The created JDBC connection."""
  jdbcConnection: JdbcConnection!
}

type JdbcConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!

  """The created/updated JDBC connections."""
  jdbcConnections: [JdbcConnection]!
}

"""A JMS Destination"""
type JmsDestination {
  """The goid for the JMS Destination"""
  goid: ID!

  """The goid for the JMS Connection"""
  connectionGoid: ID!

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String!

  """The JMS provider type"""
  providerType: String!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetails!

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetails!

  """Whether this JMS destination is template"""
  template: Boolean!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityProperty!]!

  """The configuration checksum of this JMS destination"""
  checksum: String!
}

input JmsDestinationInput {
  """The internal entity unique identifier"""
  goid: ID
  connectionGoid: ID

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String!

  """The JMS provider type"""
  providerType: String!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetailsInput

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetailsInput

  """Whether this JMS destination is template"""
  template: Boolean!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityPropertyInput!]!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input JmsDestinationPartialInput {
  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String

  """The JMS provider type"""
  providerType: String

  """The initial context factory class name"""
  initialContextFactoryClassname: String

  """The connection factory name"""
  connectionFactoryName: String

  """The JNDI URL"""
  jndiUrl: String

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetailsInput

  """The destination type"""
  destinationType: String

  """The destination name"""
  destinationName: String

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetailsInput

  """Whether this JMS destination is template"""
  template: Boolean

  """Whether this JMS destination is enabled"""
  enabled: Boolean

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityPropertyInput!]
}

type JmsDestinationPayload implements EntityMutationPayload {
  status: EntityMutationStatus!

  """The created JMS destination."""
  jmsDestination: JmsDestination!
}

type JmsDestinationsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!

  """The created/updated JMS destinations."""
  jmsDestinations: [JmsDestination]!
}

"""A JMS SSL Details"""
type JmsSslDetails {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

input JmsSslDetailsInput {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

"""Defines a current status of a given scheduled task"""
enum JobStatus {
  SCHEDULED
  COMPLETED
  DISABLED
}

"""Defines a scheduled task type"""
enum JobType {
  ONE_TIME
  RECURRING
}

"""
This is an entry in the gateway keystore. These entries combine a private
key and associated certificate and are used for example by listener ports
These represent the gateway's own certificates as opposed to the Certificate
type which represent a cert trusted by the gateway.
"""
type Key {
  alias: String!
  subjectDn: String!
  goid: ID!
  checksum: String!
  keyType: String!

  """The certificate chain in PEM format"""
  certChain: [String!]!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String!
}

input KeyInput {
  alias: String!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String!

  """Will try to match at creation time is specified"""
  goid: ID

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String
}

type KeysPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  keys: [Key!]!
}

"""
LdapIdp config itself is provided. Graphman wont get to
underlying users and groups in the ldap since they are not
part of the gateway configuration itself. When l7 policies
refer to these ldap users and groups, thee references are
interpreted by the ldap directory itself.
"""
type LdapIdp {
  name: String!
  goid: ID!
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMapping!]!
  groupMappings: [GroupMapping!]!

  """
  consider these advanced ldap configuration:
  userCertificateUseType : UserCertificateUseType!
  ntlm stuff, 8 settings and additional arbitrary props
  6 additional user cert settings
  """
  checksum: String!
}

input MembershipInput {
  name: String!
}

type MemberStrategy {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

input MemberStrategyInput {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

type Mutation {
  """Create a new policy fragment"""
  createPolicyFragment(input: PolicyFragmentInput!): PolicyFragmentPayload!

  """Update an existing policy fragment"""
  updatePolicyFragment(name: String!, input: PolicyFragmentPartialInput!): PolicyFragmentPayload!

  """Create or update policy fragments"""
  setPolicyFragments(input: [PolicyFragmentInput!]!): PolicyFragmentsPayload!

  """Delete policy fragments"""
  deletePolicyFragments(names: [String!]!): PolicyFragmentsPayload!

  """Create or update global policies"""
  setGlobalPolicies(input: [GlobalPolicyInput!]!): GlobalPoliciesPayload!

  """Delete global policies"""
  deleteGlobalPolicies(tags: [String!]!): GlobalPoliciesPayload!

  """Create a new web api service"""
  createWebApiService(input: WebApiServiceInput!): WebApiServicePayload

  """Update an existing web api service given its resolution path"""
  updateWebApiService(resolutionPath: String!, input: WebApiServicePartialInput!): WebApiServicePayload

  """Create or update web api services"""
  setWebApiServices(input: [WebApiServiceInput!]!): WebApiServicesPayload

  """Delete existing web api services given their resolution paths"""
  deleteWebApiServices(resolutionPaths: [String!]!): WebApiServicesPayload

  """Create a new soap service"""
  createSoapService(input: SoapServiceInput!): SoapServicePayload

  """Update an existing soap service"""
  updateSoapService(resolver: SoapServiceResolverInput!, input: SoapServicePartialInput!): SoapServicePayload

  """Create or update soap services"""
  setSoapServices(input: [SoapServiceInput!]!): SoapServicesPayload

  """Delete existing soap services given their resolution details"""
  deleteSoapServices(resolvers: [SoapServiceResolverInput!]!): SoapServicesPayload

  """Create a new Encapsulated Assertion Configuration"""
  createEncassConfig(input: EncassConfigInput!): EncassConfigPayload!

  """Update an existing Encapsulated Assertion Configuration given its name"""
  updateEncassConfig(name: String!, input: EncassConfigPartialInput!): EncassConfigPayload!

  """Create or update Encapsulated Assertion Configurations"""
  setEncassConfigs(input: [EncassConfigInput!]!): EncassConfigsPayload

  """Delete existing Encapsulated Assertion Configurations"""
  deleteEncassConfigs(names: [String!]!): EncassConfigsPayload

  """
  Create or update existing cluster properties.  If a cluster property with the given name does not
  exist, one will be created, otherwise the existing one will be updated. This returns the list of
  entities created and/or updated
  """
  setClusterProperties(input: [ClusterPropertyInput!]!): ClusterPropertiesPayload!

  """Delete existing cluster properties"""
  deleteClusterProperties(names: [String!]!): ClusterPropertiesPayload!

  """
  Create a trusted certificate.
  If a certificate with the same sha1 thumbprint already exist, the mutation will fail
  """
  createTrustedCert(input: TrustedCertInput!): TrustedCertPayload!

  """
  Update an existing trusted certificate.
  If no trusted certificate with the same sha1 thumbprint exist, the mutation will fail
  """
  updateTrustedCert(input: TrustedCertPartialInput!): TrustedCertPayload!
  setTrustedCerts(input: [TrustedCertInput!]!): TrustedCertsPayload!

  """Delete an existing certificates"""
  deleteTrustedCerts(thumbprintSha1s: [String!]!): TrustedCertsPayload!

  """
  Create a JDBC connection.
  If a JDBC connection with the same name already exists, the creation will fail
  """
  createJdbcConnection(input: JdbcConnectionInput!): JdbcConnectionPayload!

  """
  Update an existing JDBC connection.
  If no JDBC connection with the same name exist, the update will fail
  """
  updateJdbcConnection(input: JdbcConnectionPartialInput!): JdbcConnectionPayload!

  """
  Create or update JDBC connections.
  If JDBC connection with the same name exist, the JDBC connection will be updated.
  If no JDBC connection with the name exist, a new JDBC connection will be created.
  """
  setJdbcConnections(input: [JdbcConnectionInput!]!): JdbcConnectionsPayload!

  """Deletes JDBC connections."""
  deleteJdbcConnections(
    """The names of the JDBC connection to delete"""
    names: [String!]!
  ): JdbcConnectionsPayload

  """
  Create a Cassandra connection.
  If a Cassandra connection with the same name already exists, the creation will fail
  """
  createCassandraConnection(input: CassandraConnectionInput!): CassandraConnectionPayload!

  """
  Update an existing Cassandra connection.
  If no Cassandra connection with the same name exist, the update will fail
  """
  updateCassandraConnection(input: CassandraConnectionPartialInput!): CassandraConnectionPayload!

  """
  Create or update Cassandra connections.
  If Cassandra connection with the same name exist, the Cassandra connection will be updated.
  If no Cassandra connection with the name exist, a new Cassandra connection will be created.
  """
  setCassandraConnections(input: [CassandraConnectionInput!]!): CassandraConnectionsPayload!

  """Deletes Cassandra connections."""
  deleteCassandraConnections(
    """The names of the Cassandra connection to delete"""
    names: [String!]!
  ): CassandraConnectionsPayload!

  """
  Create a JMS destination.
  If a JMS destination with the same name already exists, the creation will fail
  """
  createJmsDestination(input: JmsDestinationInput!): JmsDestinationPayload!

  """
  Update an existing JMS destination.
  If no JMS connection with the same name exist, the update will fail
  """
  updateJmsDestination(input: JmsDestinationPartialInput!): JmsDestinationPayload!

  """
  Create or update JMS destinations.
  If JMS destination with the same name exist, the JMS destination will be updated.
  If no JMS destination with the name exist, a new JMS destination will be created.
  """
  setJmsDestinations(input: [JmsDestinationInput!]!): JmsDestinationsPayload!

  """Deletes JMS destinations."""
  deleteJmsDestinations(
    """The names of the JMS destination to delete"""
    names: [String!]!
  ): JmsDestinationsPayload

  """Create a single XML schema"""
  createSchema(input: SchemaInput!): SchemaPayload

  """Create or Update multiple XML schemas"""
  setSchemas(input: [SchemaInput!]!): SchemasPayload

  """Delete multiple XML schemas"""
  deleteSchemas(systemIds: [String!]!): SchemasPayload

  """Create a single DTD resource"""
  createDtd(input: DtdInput!): DtdPayload

  """Create or Update multiple DTD resources"""
  setDtds(input: [DtdInput!]!): DtdsPayload

  """Delete multiple DTD resources"""
  deleteDtds(systemIds: [String!]!): DtdsPayload
  setFips(input: [CreateFipInput!]!): SetFipsPayload
  setLdapIdps(input: [CreateLdapInput!]!): SetLdapIdpsPayload

  """
  Deletes either a FIP or a LDAP IdP based on its name. You can't delete the internal idp by passing the name Internal
  """
  deleteIdp(name: String!): DeleteIdpPayload
  setInternalUsers(input: [CreateInternalUserInput!]!): SetInternalUsersPayload
  setInternalGroups(input: [CreateInternalGroupInput!]!): SetInternalGroupsPayload
  deleteInternalUser(login: String!): DeleteInternalUserPayload
  deleteInternalGroup(name: String!): DeleteInternalGroupPayload
  setFipUsers(input: [CreateFipUserInput!]!): SetFipUsersPayload
  setFipGroups(input: [CreateFipGroupInput!]!): SetFipGroupsPayload
  deleteFipUser(fipName: String!, userName: String!): DeleteFipUserPayload
  deleteFipGroup(fipName: String!, groupName: String!): DeleteFipGroupPayload
  setSecrets(input: [SecretInput!]!): SecretsPayload
  setKeys(input: [KeyInput!]!): KeysPayload
  deleteSecrets(names: [String!]!): SecretsPayload
  deleteKeys(aliases: [String!]!): KeysPayload

  """Changes the certificate portion of a key entry"""
  reCert(input: RecertInput!): RecertPayload

  """
  Creates (Uploads) Server module file.
  If a Server module file with the same name already exists, the create (upload) will fail
  """
  createServerModuleFile(input: ServerModuleFileInput!): ServerModuleFilePayload!

  """
  Sets Server module files. Updating the existing server module file is unsupported.
  """
  setServerModuleFiles(input: [ServerModuleFileInput!]!): ServerModuleFilesPayload

  """Deletes Server module files."""
  deleteServerModuleFiles(
    """The names of the Server module file to delete"""
    names: [String!]!
  ): ServerModuleFilesPayload

  """Creates or updates one or more scheduled tasks"""
  setScheduledTasks(input: [ScheduledTaskInput!]!): ScheduledTasksPayload!

  """Creates or updates one or more background task policies"""
  setBackgroundTaskPolicies(input: [BackgroundTaskPolicyInput!]!): BackgroundTaskPoliciesPayload!

  """Deletes one or more existing scheduled tasks"""
  deleteScheduledTasks(names: [String!]!): ScheduledTasksPayload!

  """Deletes an existing background task policy"""
  deleteBackgroundTaskPolicies(names: [String!]!): BackgroundTaskPoliciesPayload!
}

"""An Integer that MUST be greater than or equal to zero"""
scalar NonNegativeInt

type PasswdStrategy {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

input PasswdStrategyInput {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

"""Wrapper for the policy XML and the dependencies they include"""
type Policy {
  """The policy XML"""
  xml: String!

  """Entities that are directly referred to inside the policy XML"""
  directDependencies: PolicyDependency

  """
  Entities that are directly referred to inside the policy XML in addition to
  ones in policy dependencies. More than second level, this keep going as deep
  as needed until no dependencies are found
  """
  allDependencies: PolicyDependency
}

"""
Policy Dependency contains all dependencies that may be referred to from the policy XML this is associated with
"""
type PolicyDependency {
  """Policy Fragments"""
  policyFragments: [PolicyFragment]

  """Cluster properties"""
  clusterProperties: [ClusterProperty]

  """Trusted certificates"""
  trustedCerts: [Certificate]

  """Encass Configs"""
  encassConfigs: [EncassConfig]

  """JDBC connections"""
  jdbcConnections: [JdbcConnection]

  """Cassandra connections"""
  cassandraConnections: [CassandraConnection]

  """JMS destinations"""
  jmsDestinations: [JmsDestination]

  """Schemas in global resources"""
  schemas: [Schema]

  """DTDs in global resources"""
  dtds: [Dtd]

  """Federated identity provider configurations"""
  fips: [Fip]

  """Ldap identity provider configurations"""
  ldapIdps: [LdapIdp]

  """Internal idp users"""
  internalUsers: [InternalUser]

  """Internal idp groups"""
  internalGroups: [InternalGroup]

  """Federated identity provider users"""
  fipUsers: [FipUser]

  """Federated identity provider group"""
  fipGroups: [FipGroup]
  secrets: [Secret]
  keys: [Key]
  serverModuleFiles: [ServerModuleFile]
}

"""A policy fragment that can be included in another policy"""
type PolicyFragment {
  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """The name of the policy (policies are unique by name)"""
  name: String!

  """The folder path to the policy"""
  folderPath: String!

  """The actual policy and dependencies"""
  policy: Policy!

  """The configuration checksum"""
  checksum: String!
}

input PolicyFragmentInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the policy. Policies are unique by name."""
  name: String!

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """The policy"""
  policy: PolicyInput!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input PolicyFragmentPartialInput {
  """The new name of the policy"""
  name: String

  """The new location this policy."""
  folderPath: String

  """The new policy for this policy :)"""
  policy: PolicyInput
}

type PolicyFragmentPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  policyFragment: PolicyFragment!
}

type PolicyFragmentsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  policyFragments: [PolicyFragment]!
}

input PolicyInput {
  """The policy xml"""
  xml: String!
}

enum PolicyUsageType {
  """Do not perform revocation check"""
  NONE

  """Use the default revocation check policy"""
  USE_DEFAULT

  """Use the specified revocation check policy"""
  SPECIFIED
}

"""An Integer that MUST be greater than zero"""
scalar PositiveInt

type Query {
  """Get all policy fragments"""
  policyFragments: [PolicyFragment!]!

  """Get policy fragment by name"""
  policyFragmentByName(name: String!): PolicyFragment

  """Get policy fragments inside a folder"""
  policyFragmentsByFolderPath(folderPath: String!): [PolicyFragment]!

  """Get policy fragment by goid"""
  policyFragmentByGoid(goid: ID!): PolicyFragment

  """Get policy fragment by guid"""
  policyFragmentByGuid(guid: ID!): PolicyFragment

  """Get all global policies"""
  globalPolicies: [GlobalPolicy!]!

  """Get global policy by tag"""
  globalPolicyByTag(tag: String!): GlobalPolicy

  """Get all webApi services"""
  webApiServices: [WebApiService]!

  """Get webApi services by name"""
  webApiServicesByName(name: String!): [WebApiService!]!

  """Get webApi service by name. Returns none if more than one are found."""
  webApiServiceByName(name: String!): WebApiService

  """Get webApi services by resolutionPath"""
  webApiServicesByResolutionPath(resolutionPath: String!): [WebApiService!]!

  """
  Get webApi service by resolutionPath. Returns none if more than one are found.
  """
  webApiServiceByResolutionPath(resolutionPath: String!): WebApiService

  """Get webApi services inside a folder"""
  webApiServicesByFolderPath(folderPath: String!): [WebApiService]!

  """Get webApi services by goid"""
  webApiServiceByGoid(goid: ID!): WebApiService

  """Get all soap services"""
  soapServices: [SoapService]!

  """Get soap services by name"""
  soapServicesByName(name: String!): [SoapService]!

  """Get soap service by name. Returns none if more than one are found."""
  soapServiceByName(name: String!): SoapService

  """Get soap services inside a folder"""
  soapServicesByFolderPath(folderPath: String!): [SoapService]!

  """Get soap service by goid"""
  soapServiceByGoid(goid: ID!): SoapService

  """Get soap service by resolver"""
  soapServiceByResolver(resolver: SoapServiceResolverInput!): SoapService

  """Get all Encapsulated Assertion Configurations"""
  encassConfigs: [EncassConfig!]!

  """Get Encapsulated Assertion Configuration by name"""
  encassConfigByName(name: String!): EncassConfig

  """Get Encapsulated Assertion Configuration by goid"""
  encassConfigByGoid(goid: ID!): EncassConfig

  """Get Encapsulated Assertion Configuration by guid"""
  encassConfigByGuid(guid: ID!): EncassConfig

  """Get all cluster properties"""
  clusterProperties: [ClusterProperty!]!

  """Get the cluster property with the given name"""
  clusterPropertyByName(name: String!): ClusterProperty

  """Retrieves all trusted certificates"""
  trustedCerts: [Certificate!]!

  """Retrieves a list of trusted certificates with the matching subject dn"""
  trustedCertsByDn(subjectDn: String!): [Certificate]!

  """The trusted certificate associated with this unique thumbprint"""
  trustedCertByThumbprint(thumbprintSha1: String!): Certificate

  """Get all JDBC Connections"""
  jdbcConnections: [JdbcConnection!]!

  """Get JDBC Connection by name"""
  jdbcConnectionByName(name: String!): JdbcConnection

  """Get JDBC Connection by goid"""
  jdbcConnectionByGoid(goid: ID!): JdbcConnection

  """Get all Cassandra Connections"""
  cassandraConnections: [CassandraConnection!]!

  """Get Cassandra Connection by name"""
  cassandraConnectionByName(name: String!): CassandraConnection

  """Get Cassandra Connection by goid"""
  cassandraConnectionByGoid(goid: ID!): CassandraConnection

  """Get all JMS Destinations"""
  jmsDestinations: [JmsDestination!]!

  """Get JMS Destination by name"""
  jmsDestinationByName(name: String!): JmsDestination

  """Get JMS Destination by goid"""
  jmsDestinationByGoid(goid: ID!): JmsDestination

  """Get xml schemas configured on this gateway"""
  schemas: [Schema!]!

  """The schema given its system id"""
  schemaBySystemId(systemId: String!): Schema

  """The dtds configured on this gateway"""
  dtds: [Dtd!]!

  """The dtd given its system id"""
  dtdBySystemId(systemId: String!): Dtd

  """Get internal schemas, for reference only"""
  internalSchemas: [Schema!]!

  """Get internal dtds, for reference only"""
  internalDtds: [Dtd!]!
  internalUsers: [InternalUser!]!
  internalGroups: [InternalGroup!]!
  fips: [Fip!]!
  fipUsers: [FipUser!]!
  fipGroups: [FipGroup!]!
  ldapIdps: [LdapIdp!]!
  searchIdp(filter: IdpFilter!): IdpSearchResult!
  internalUserByLogin(login: String!): InternalUser
  internalGroupByName(name: String!): InternalGroup
  fipByName(name: String!): Fip
  fipUserByName(providerName: String!, userName: String!): FipUser
  fipGroupByName(providerName: String!, groupName: String!): FipGroup
  ldapIdpByName(name: String!): LdapIdp
  secrets: [Secret!]!
  keys: [Key!]!
  secretByName(name: String!): Secret
  keyByAlias(alias: String!): Key

  """Get all Server module files"""
  serverModuleFiles: [ServerModuleFile!]!

  """Get Server module file by name"""
  serverModuleFileByName(name: String!): ServerModuleFile

  """Retrieves all scheduled tasks"""
  scheduledTasks: [ScheduledTask!]!

  """Retrieves all background task policies"""
  backgroundTaskPolicies: [BackgroundTaskPolicy!]!

  """Retrieves a scheduled task by name"""
  scheduledTaskByName(name: String!): ScheduledTask

  """Retrieves a background task policy by name"""
  backgroundTaskPolicyByName(name: String!): BackgroundTaskPolicy
}

input RecertInput {
  alias: String!

  """The cert chain to apply in PEM format"""
  certChain: [String!]!
}

type RecertPayload {
  recertified: Boolean!
  key: Key
}

"""A revocation check policy for certificates"""
type RevocationCheckPolicy {
  """The goid for this revocation check policy"""
  goid: ID!

  """The name for this revocation check policy"""
  name: String!
}

"""A scheduled task"""
type ScheduledTask {
  name: String!
  policyName: String!
  jobType: JobType!
  cronExpression: String
  executeOnSingleNode: Boolean!
  executeOnCreation: Boolean!

  """Execution date of a ONE_TIME task"""
  executionDate: DateTime
  status: JobStatus!
  runAsUser: String
  runAsUserProviderName: String
  goid: ID!
  checksum: String!
}

input ScheduledTaskInput {
  """The internal entity unique identifier"""
  goid: ID
  name: String!
  policyName: String!
  jobType: JobType!
  cronExpression: String
  executeOnSingleNode: Boolean!

  """Whether to execute the RECURRING task now?"""
  executeOnCreation: Boolean!

  """Specify a future execution date for a ONE_TIME task"""
  executionDate: DateTime
  status: JobStatus
  runAsUser: String
  runAsUserProviderName: String
  checksum: String
}

type ScheduledTasksPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  scheduledTasks: [ScheduledTask]!
}

"""
An XML Schema which can be referred to in policy, for example in the validate xml schema assertion
"""
type Schema {
  """Internal goid for this schema"""
  goid: ID!

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The target namespace in the xml schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!

  """The configuration checksum"""
  checksum: String!
}

input SchemaInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The target namespace in the XML schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type SchemaPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  schema: Schema!
}

type SchemasPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  schemas: [Schema]!
}

"""
These secrets are used by gateway policies also for example by jdbc connection configurations
"""
type Secret {
  name: String!
  secretType: SecretType!
  goid: ID!
  checksum: String!

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can decrypt these values at command line
  using this command:
  > echo <secret> | openssl enc -d -aes-256-cbc -md sha256 -pass pass:<passphrase> -a
  """
  secret: String!
  description: String
}

input SecretInput {
  name: String!
  secretType: SecretType!
  goid: ID

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can create this value at command line:
  > echo -n "<clear text secret>" | openssl enc -aes-256-cbc -md sha256 -pass pass:<password> -a
  """
  secret: String!
  description: String
}

type SecretsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  secrets: [Secret!]!
}

enum SecretType {
  """Stored password for example used in the jdbc connection"""
  PASSWORD

  """Secure pem key for example used in the route via ssh assertion"""
  PEM_PRIVATE_KEY
}

"""A Server module file"""
type ServerModuleFile {
  """The goid for the Server module file"""
  goid: ID!

  """The Server module name"""
  name: String!

  """The Server module type"""
  moduleType: String!

  """The Server module SHA256 digest value"""
  moduleSha256: String!

  """The Server module file properties"""
  properties: [EntityProperty!]!

  """
  The dummy field, is used to get the Server module file content in separate part
  """
  filePartName: String!

  """The configuration checksum of this Server module file"""
  checksum: String!
}

input ServerModuleFileInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Server module name"""
  name: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ServerModuleFilePayload implements EntityMutationPayload {
  status: EntityMutationStatus!

  """The created Server module file."""
  serverModuleFile: ServerModuleFile!
}

type ServerModuleFilesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!

  """The created Server module files."""
  serverModuleFiles: [ServerModuleFile]!
}

type SetFipGroupsPayload {
  fipGroups: [FipGroup!]!
}

type SetFipsPayload {
  fips: [Fip!]!
}

type SetFipUsersPayload {
  fipUsers: [FipUser!]!
}

type SetInternalGroupsPayload {
  internalGroups: [InternalGroup!]!
}

type SetInternalUsersPayload {
  internalUsers: [InternalUser!]!
}

type SetLdapIdpsPayload {
  ldapIdps: [LdapIdp!]!
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
type SoapResolvers {
  """The soap actions referred to in the wsdl"""
  soapActions: [String!]!

  """
  Base uri from the wsdl of the service. This is used for service resolution
  """
  baseUri: String

  """The resolution path to the service if not default /ssg/soap"""
  resolutionPath: String
}

"""A Soap service published on the Layer7 Gateway"""
type SoapService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID!

  """The name of the service"""
  name: String!

  """The folder path to the service"""
  folderPath: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """Soap service resolvers"""
  resolvers: SoapResolvers!

  """Which SOAP version"""
  soapVersion: String!
  wssProcessingEnabled: Boolean!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed if not just POST"""
  methodsAllowed: [HttpMethod!]

  """The configuration checksum"""
  checksum: String!
}

input SoapServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the service"""
  name: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """The resolution path of the service"""
  resolutionPath: String

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default true)"""
  enabled: Boolean

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!

  """
  Whether or not the gateway should process incoming ws-security soap headers
  """
  wssProcessingEnabled: Boolean!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input SoapServicePartialInput {
  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: String

  """The name of the service"""
  name: String

  """The WSDL of the soap service"""
  wsdl: String

  """The resolution path of the service"""
  resolutionPath: String

  """The policy"""
  policy: PolicyInput

  """Whether the service is enabled"""
  enabled: Boolean

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]

  """
  Whether or not the gateway should process incoming ws-security soap headers
  """
  wssProcessingEnabled: Boolean
}

type SoapServicePayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  soapService: SoapService!
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
input SoapServiceResolverInput {
  """
  One of the SoapAction of the service to resolved. This must be specified along with a base ns from the WSDL
  """
  soapAction: String

  """
  Base uri from the wsdl of the service. Use this alongside the soapaction
  property to resolve a soap service without resolutionUri
  """
  baseUri: String

  """
  The resolution path of the service if that is how the soap service is resolved
  """
  resolutionPath: String
}

type SoapServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  soapServices: [SoapService]!
}

"""Input sent with createTrustedCert mutation"""
input TrustedCertInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the trusted certificate"""
  name: String!

  """The base 64 encoded string of the certificate"""
  certBase64: String!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """What the certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """
  The name of revocation policy.  Required if revocationCheckPolicyType is PolicyUsageType.SPECIFIED
  """
  revocationCheckPolicyName: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""
Input sent with updateTrustedCert mutation. Only fields specified will be updated
"""
input TrustedCertPartialInput {
  """The sha1 thumbprint identifying the trusted certificate"""
  thumbprintSha1: String!

  """The name of the trusted certificate"""
  name: String

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean

  """What the certificate is trusted for"""
  trustedFor: [TrustedForType!]

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType

  """
  The name of revocation policy.  Required if revocationCheckPolicyType is PolicyUsageType.SPECIFIED
  """
  revocationCheckPolicyName: String
}

type TrustedCertPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  trustedCert: Certificate!
}

type TrustedCertsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  trustedCerts: [Certificate]!
}

"""Defines what a certificate is trusted for"""
enum TrustedForType {
  """Is trusted as an SSL server cert"""
  SSL

  """Is trusted as a CA that signs SSL server certs"""
  SIGNING_SERVER_CERTS

  """Is trusted as a CA that signs SSL client certs"""
  SIGNING_CLIENT_CERTS

  """Is trusted to sign SAML tokens"""
  SAML_ISSUER

  """Is trusted as a SAML attesting entity"""
  SAML_ATTESTING_ENTITY
}

type UserMapping {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategy!
}

input UserMappingInput {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategyInput!
}

"""A Web API service published on the Layer7 Gateway"""
type WebApiService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID!

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String!

  """The folder path to the service"""
  folderPath: String!

  """The policy and dependencies"""
  policy: Policy!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """Which http methods are allowed"""
  methodsAllowed: [HttpMethod!]!

  """The configuration checksum"""
  checksum: String!
}

input WebApiServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the service"""
  name: String!

  """The resolution path of the service"""
  resolutionPath: String!

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default to true)"""
  enabled: Boolean

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input WebApiServicePartialInput {
  """
  The folder path where to move this service.  If the path does not exist, it will be created
  """
  folderPath: String

  """The new name of the service"""
  name: String

  """The resolution path of the service."""
  resolutionPath: String

  """The policy"""
  policy: PolicyInput

  """Whether the service is enabled"""
  enabled: Boolean

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]
}

type WebApiServicePayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  webApiService: WebApiService!
}

type WebApiServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  webApiServices: [WebApiService]!
}

