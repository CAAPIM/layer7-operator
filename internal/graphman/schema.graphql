"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type ActiveConnector {
  """The goid for the active connector"""
  goid: ID!

  """The active connector name"""
  name: String!

  """The configuration checksum of this active connector"""
  checksum: String!

  """Whether this active connector is enabled"""
  enabled: Boolean!

  """The active connector type - KAFKA, SFTP_POLLING_LISTENER, MQ_NATIVE"""
  connectorType: ActiveConnectorType!

  """The name of the published service hardwired to the active connector"""
  hardwiredServiceName: String

  """The active connector Properties"""
  properties: [EntityProperty!]

  """The advanced properties for active connector"""
  advancedProperties: [EntityProperty!]

  """The published service hardwired to the active connector"""
  hardwiredService: HardwiredService
}

input ActiveConnectorInput {
  """The internal entity unique identifier"""
  goid: ID

  """The active connector name"""
  name: String!

  """Whether this active connector is enabled"""
  enabled: Boolean!

  """The active connector type - KAFKA, SFTP_POLLING_LISTENER, MQ_NATIVE"""
  connectorType: ActiveConnectorType!

  """The name of the published service hardwired to the active connector"""
  hardwiredServiceName: String

  """The active connector properties"""
  properties: [EntityPropertyInput!]

  """The advanced properties for active connector"""
  advancedProperties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ActiveConnectorsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated active connectors"""
  activeConnectors: [ActiveConnector]!
}

enum ActiveConnectorType {
  KAFKA
  SFTP_POLLING_LISTENER
  MQ_NATIVE
}

type AdministrativeUserAccountPropertiesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  administrativeUserAccountProperties: [AdministrativeUserAccountProperty]!
}

"""An Administrative User Account Minimum Property"""
type AdministrativeUserAccountProperty {
  """The administrative user account minimum property unique identifier"""
  goid: ID!

  """The name of administrative user account minimum property"""
  name: String!

  """The value of the administrative user account minimum property"""
  value: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""The inputs sent with the setClusterProperty Mutation"""
input AdministrativeUserAccountPropertyInput {
  """The administrative user account minimum property unique identifier"""
  goid: ID

  """The name of administrative user account minimum property"""
  name: String!

  """The value of the administrative user account minimum property"""
  value: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""An Object scalar that can be a valid JSON object"""
scalar AnyObject

type AnyProperty {
  """The name of property"""
  name: String!

  """The value of the property"""
  value: AnyObject
}

type BackgroundTaskPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  backgroundTaskPolicies: [BackgroundTaskPolicy]!
}

"""
A background task policy that is associated with a scheduled task to be run
"""
type BackgroundTaskPolicy {
  """The internal entity unique identifier"""
  goid: ID!

  """The internal entity unique identifier"""
  guid: ID!

  """The name of the background task policy"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """The folder path of the background task policy"""
  folderPath: String!
  soap: Boolean

  """The background task policy"""
  policy: Policy!
}

input BackgroundTaskPolicyInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the background task policy"""
  name: String!

  """The internal entity unique identifier"""
  guid: ID

  """The folder path background task policy"""
  folderPath: String!

  """The background task policy"""
  policy: PolicyInput!
  soap: Boolean = false

  """The configuration checksum"""
  checksum: String
}

type BundleEntitiesPayload {
  summary: Boolean
  full: Boolean
}

enum CassandraCompression {
  NONE
  LZ4
}

"""A Cassandra Connection"""
type CassandraConnection {
  """The goid for the Cassandra Connection"""
  goid: ID!

  """The Cassandra Connection name"""
  name: String!

  """The configuration checksum of this Cassandra connection"""
  checksum: String!

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra keyspace name"""
  keyspace: String!

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The Cassandra connection compression type"""
  compression: CassandraCompression!

  """The username"""
  username: String

  """The secure password reference."""
  securePasswordName: String

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """The Cassandra connection properties"""
  properties: [EntityProperty!]
}

input CassandraConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Cassandra Connection name"""
  name: String!

  """The Cassandra keyspace name"""
  keyspace: String! = ""

  """The Cassandra connection points"""
  contactPoints: [String!]!

  """The Cassandra server port"""
  port: PositiveInt!

  """The username"""
  username: String! = ""

  """The secure password reference."""
  securePasswordName: String

  """The Cassandra connection compression type"""
  compression: CassandraCompression = NONE

  """Whether this Cassandra connection is SSL enabled"""
  sslEnabled: Boolean!

  """Cipher suites used for SSL connection"""
  cipherSuites: [String!]

  """Whether this Cassandra connection is enabled"""
  enabled: Boolean!

  """The Cassandra connection properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type CassandraConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated Cassandra connections."""
  cassandraConnections: [CassandraConnection]!
}

"""An certificate that is trusted by the Gateway"""
type Certificate {
  """The goid for this certificate"""
  goid: ID!

  """The name"""
  name: String!

  """The Subject DN of this certificate"""
  subjectDn: String!

  """The sha1 thumbprint of the certificate"""
  thumbprintSha1: String!

  """The configuration checksum of this trusted certificate"""
  checksum: String!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """The certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """
  The name of revocation policy.  Required if revocationCheckPolicyType is PolicyUsageType.SPECIFIED
  """
  revocationCheckPolicyName: String

  """The specified revocation policy"""
  revocationCheckPolicy: RevocationCheckPolicy

  """The start date of the validity period"""
  notBefore: DateTime!

  """the end date of the validity period"""
  notAfter: DateTime!

  """The base 64 encoded string of this certificate"""
  certBase64: String!
}

enum CertificateValidationType {
  CERTIFICATE_ONLY
  PATH_VALIDATION
  REVOCATION
}

enum CertRevocationCheckPropertyType {
  """
  Type for checking against a CRL from a URL contained in an X.509 Certificate
  """
  CRL_FROM_CERTIFICATE

  """Type for checking against a CRL from a specified URL"""
  CRL_FROM_URL

  """
  Type for OCSP check against a responder URL contained in an X.509 Certificate
  """
  OCSP_FROM_CERTIFICATE

  """Type for OCSP check against a specified responder URL"""
  OCSP_FROM_URL
}

type ClusterInfo {
  """cluster Name"""
  name: String

  """cluster Nodes Info"""
  nodes: [ClusterNodeInfo!]!
}

type ClusterNodeInfo {
  """cluster node id"""
  nodeId: String!

  """cluster node name"""
  name: String!

  """cluster node IP Address"""
  address: String!

  """cluster node uptime"""
  uptime: Int!
}

type ClusterPropertiesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  clusterProperties: [ClusterProperty]!
}

"""Cluster properties are used to set global properties"""
type ClusterProperty {
  """The goid for the cluster property"""
  goid: ID!

  """The cluster property name"""
  name: String!

  """The configuration checksum of this cluster prop"""
  checksum: String!

  """The cluster property description"""
  description: String

  """Whether this is a hidden property"""
  hiddenProperty: Boolean!

  """The cluster property value"""
  value: String!
}

"""The inputs sent with the setClusterProperty Mutation"""
input ClusterPropertyInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the cluster property"""
  name: String!

  """The value of the cluster property to set"""
  value: String!

  """The cluster property description"""
  description: String

  """
  Whether this is a hidden property. (Note that, this field has no effect on the mutation)
  """
  hiddenProperty: Boolean

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""Cluster properties are used to set global properties"""
type CustomKeyValue {
  """The goid for the custom key value"""
  goid: ID!

  """The custom key"""
  key: String!

  """The configuration checksum of this custom key value"""
  checksum: String!

  """The custom value in Base64 encoded format"""
  value: String!
}

"""The inputs sent with the setCustomKeyValue Mutation"""
input CustomKeyValueInput {
  """The goid for the custom key value"""
  goid: ID

  """The custom key"""
  key: String!

  """The custom value in Base64 encoded format"""
  value: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type CustomKeyValuePayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  customKeyValues: [CustomKeyValue]!
}

enum DataType {
  STRING
  CERTIFICATE
  INTEGER
  DECIMAL
  FLOAT
  ELEMENT
  BOOLEAN
  BINARY
  DATE_TIME
  MESSAGE
  BLOB
  CLOB
  UNKNOWN
}

"""
An RFC-3339 compliant date time scalar that accepts string values like `1996-12-19T16:39:57-08:00`
"""
scalar DateTime

"""A Document Type Definition (DTD) which can be referred to in policy"""
type Dtd {
  """Internal goid for this DTD"""
  goid: ID!

  """
  A reference to the DTD. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The configuration checksum"""
  checksum: String!

  """The public id for the DTD"""
  publicId: String

  """An optional description"""
  description: String

  """The content of DTD itself"""
  content: String!
}

input DtdInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the dtd. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The public id for the dtd"""
  publicId: String

  """An optional description"""
  description: String

  """The actual dtd itself"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type DtdsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  dtds: [Dtd]!
}

type EmailListener {
  """The goid for the email listener Connection"""
  goid: ID!

  """
  The name of the email listener. If you are creating several listeners, make sure the name is descriptive
  """
  name: String!

  """The configuration checksum"""
  checksum: String!

  """Whether this email listener is enabled(active)"""
  enabled: Boolean!

  """The type of email server (IMAP or POP3)"""
  serverType: EmailServerType!

  """
  The hostname of the email server. This name is verified against the X.509 certificate
  """
  hostname: String!

  """The port number to monitor"""
  port: PositiveInt!

  """The folder name to check for emails (Only for IMAP)"""
  folder: String!

  """Whether delete the messages on the mail server after retrieving"""
  deleteOnReceive: Boolean!

  """Email account name"""
  username: String!

  """
  Email account password. The password could be in plain text or secure password reference
  """
  password: String!

  """The name of the published service hardwired to the email listener"""
  hardwiredServiceName: String

  """Whether email server connection (POP3S or IMAPS) is SSL enabled"""
  sslEnabled: Boolean!

  """
  The listener will check for email after the specified number of seconds
  """
  pollInterval: PositiveInt!

  """Permitted maximum size of the message"""
  sizeLimit: NonNegativeInt

  """
  The email listener properties excluding sizeLimit and HardwiredServiceName
  """
  properties: [EntityProperty!]

  """The published service hardwired to the email listener"""
  hardwiredService: HardwiredService
}

input EmailListenerInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The name of the email listener. If you are creating several listeners, make sure the name is descriptive
  """
  name: String!

  """Whether this email listener is enabled(active)"""
  enabled: Boolean!

  """
  The hostname of the email server. This name is verified against the X.509 certificate
  """
  hostname: NonEmptyString!

  """The port number to monitor"""
  port: PositiveInt!

  """The type of email server (IMAP or POP3)"""
  serverType: EmailServerType!

  """Whether email server connection (POP3S or IMAPS) is SSL enabled"""
  sslEnabled: Boolean!

  """Whether delete the messages on the mail server after retrieving"""
  deleteOnReceive: Boolean!

  """The folder name to check for emails (Only for IMAP)"""
  folder: String!

  """
  The listener will check for email after the specified number of seconds
  """
  pollInterval: PositiveInt!

  """Email account name"""
  username: String!

  """
  Email account password. The password could be in plain text or secure password reference
  """
  password: String!

  """The name of the published service hardwired to the email listener"""
  hardwiredServiceName: String

  """Permitted maximum size of the message"""
  sizeLimit: NonNegativeInt

  """
  [Optional] The Email listener Properties excluding sizeLimit and
  HardwiredServiceName. When specified, will replace existing properties
  """
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type EmailListenersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The mutated email listener connections."""
  emailListeners: [EmailListener]!
}

enum EmailServerType {
  IMAP
  POP3
}

"""The description of an input argument for an encapsulated assertion"""
type EncassArg {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: Boolean

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""
The description of an input argument for an encapsulated assertion for use when
creating or updating an existing encass config
"""
input EncassArgInput {
  """The name of the input"""
  name: String!

  """The type of input"""
  type: DataType!

  """The order of the argument in the admin gui"""
  ordinal: Int

  """The prompt in the admin gui for this encass argument"""
  guiPrompt: Boolean = false

  """The label in the admin gui associated with this encass argument"""
  guiLabel: String
}

"""An Encapsulated Assertion Configuration"""
type EncassConfig {
  """The goid for this encass config"""
  goid: ID!

  """The guid for this encass config"""
  guid: ID!

  """The name of the encass config"""
  name: String!

  """The configuration checksum of this encass"""
  checksum: String!
  description: String

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArg!]

  """the output descriptions"""
  encassResults: [EncassResult!]
  properties: [EntityProperty!]
}

"""
The description of a new encapsulated assertion configuration being created
"""
input EncassConfigInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The guid for this encass config, can be omitted and a new one is assigned
  """
  guid: ID

  """The name of the encass config"""
  name: String!
  description: String

  """The policy it points to and its dependencies"""
  policyName: String!

  """the input argument descriptions for this encass"""
  encassArgs: [EncassArgInput!]

  """the output descriptions"""
  encassResults: [EncassResultInput!]
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type EncassConfigsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  encassConfigs: [EncassConfig]!
}

"""The description of an output from the encapsulated assertion"""
type EncassResult {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

"""
The description of an output from the encapsulated assertion for use when creating or updating an existing encass config
"""
input EncassResultInput {
  """The name of the output"""
  name: String!

  """The type of the output"""
  type: DataType!
}

enum EntityFieldOption {
  DEFAULT
  NONE
  CUSTOM
}

enum EntityMutationAction {
  NEW_OR_UPDATE
  NEW_OR_EXISTING
  ALWAYS_CREATE_NEW
  IGNORE
  DELETE
}

type EntityMutationDetailedStatus {
  action: EntityMutationAction
  status: EntityMutationStatus!
  description: String
  source: [AnyProperty!]
  target: [AnyProperty!]
}

interface EntityMutationPayload {
  status: EntityMutationStatus!
  detailedStatus: EntityMutationDetailedStatus!
}

interface EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
}

enum EntityMutationStatus {
  NONE
  CREATED
  UPDATED
  DELETED
  USED_EXISTING
  IGNORED
  ERROR
}

"""An Entity Property"""
type EntityProperty {
  """The name of property"""
  name: String!

  """The value of the property"""
  value: String!
}

input EntityPropertyInput {
  name: String!
  value: String!
}

"""A Federated Identity Provider"""
type Fip {
  goid: ID!
  name: String!
  checksum: String!
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!
  certificateValidation: CertificateValidationType

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [Certificate!]!
}

input FipCertInput {
  """
  The thumbprint of the cert to use as trust for a federated identity provider
  """
  thumbprintSha1: String!

  """
  The internal entity unique identifier. (Note that, this field has no effect on the mutation)
  """
  goid: ID

  """
  The name of the trusted certificate. (Note that, this field has no effect on the mutation)
  """
  name: String

  """
  The base 64 encoded string of the certificate. (Note that, this field has no effect on the mutation)
  """
  certBase64: String

  """
  Whether to perform hostname verification with this certificate. (Note that, this field has no effect on the mutation)
  """
  verifyHostname: Boolean

  """
  Whether this certificate is a trust anchor. (Note that, this field has no effect on the mutation)
  """
  trustAnchor: Boolean

  """
  What the certificate is trusted for. (Note that, this field has no effect on the mutation)
  """
  trustedFor: [TrustedForType!]

  """
  The revocation check policy type. (Note that, this field has no effect on the mutation)
  """
  revocationCheckPolicyType: PolicyUsageType

  """
  The name of revocation policy. (Note that, this field has no effect on the mutation)
  """
  revocationCheckPolicyName: String

  """
  The Subject DN of this certificate. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """
  The start date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notBefore: String

  """
  the end date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notAfter: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

""" A group defined in a federated identity provider"""
type FipGroup {
  goid: ID!
  name: String!

  """ The name of the FiP this group is defined in """
  providerName: String!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
  description: String

  """ Fip users that member of this group """
  members: [FipUser!]!
}

input FipGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this group is defined in """
  providerName: String!
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type FipGroupsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fipGroups: [FipGroup]!
}

input FipInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID
  enableCredentialTypeSaml: Boolean!
  enableCredentialTypeX509: Boolean!
  certificateValidation: CertificateValidationType

  """ The certificates in the trusted certificate table that establish the trust for this FIP 
  """
  certificateReferences: [FipCertInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String
}

type FipSearchResult {
  fipUsers: [FipUser!]!
  fipGroups: [FipGroup!]!
}

type FipsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fips: [Fip]!
}

""" A user defined in a federated identity provider """
type FipUser {
  goid: ID!
  name: String!
  login: String

  """ The name of the FiP this user is defined as part of """
  providerName: String!
  checksum: String!
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String

  """ The list of Fip groups this user belongs to """
  memberOf: [FipGroup!]!
}

input FipUserInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID

  """ The name of the FiP this user is defined as part of """
  providerName: String!

  """
  The list of fip group details (names) that this user is member of. If you pass
  empty array, will reset memberships. If absent, does not affect memberships
  for current user.
  """
  memberOf: [MembershipInput!]
  login: String
  subjectDn: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String
  checksum: String
}

type FipUsersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  fipUsers: [FipUser]!
}

type Folder {
  """The goid for the folder"""
  goid: ID!

  """The folder name"""
  name: String!

  """The folder Path"""
  path: String!

  """The configuration checksum of this folder"""
  checksum: String!
}

input FolderInput {
  """The goid for the folder"""
  goid: ID

  """The folder name"""
  name: String

  """The folder Path"""
  path: String!

  """The configuration checksum of this folder"""
  checksum: String
}

type FoldersPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  folders: [Folder]!
}

type GlobalPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  globalPolicies: [GlobalPolicy]!
}

"""A Global policy"""
type GlobalPolicy {
  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """The name of the policy (policies are unique by name)"""
  name: String!

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The configuration checksum"""
  checksum: String!

  """The folder path where this policy is located"""
  folderPath: String!

  """The actual policy and dependencies"""
  policy: Policy!
}

input GlobalPolicyInput {
  """The name of the policy. Policies are unique by name."""
  name: String!

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The goid for this policy"""
  goid: ID

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """
  Global policy tag. Possible values are :
    message-completed
    message-received
    post-security
    post-service
    pre-security
    pre-service
  """
  tag: String!

  """The policy"""
  policy: PolicyInput!
  soap: Boolean = false

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

"""
enum UserCertificateUseType {
   NONE
   INDEX
   INDEX_CUSTOM
   SEARCH
}
"""
type GroupMapping {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategy!
}

input GroupMappingInput {
  objClass: String!
  nameAttrName: String!
  memberAttrName: String!
  memberStrategy: MemberStrategyInput!
}

union HardwiredService = SoapService | WebApiService

type HttpConfiguration {
  """The goid for the http configuration"""
  goid: ID!

  """The host of the http configuration"""
  host: String!

  """The port of the http configuration"""
  port: Int

  """The protocol of the http configuration"""
  protocol: HttpScheme

  """The path of the http configuration"""
  path: String

  """The configuration checksum of this http configuration"""
  checksum: String!

  """The username of the http configuration"""
  username: String

  """The securePasswordName of the http configuration"""
  securePasswordName: String

  """The ntlmHost of the http configuration"""
  ntlmHost: String

  """The ntlmDomain of the http configuration"""
  ntlmDomain: String

  """The tlsVersion of the http configuration"""
  tlsVersion: String

  """The tlsKeyUse of the http configuration"""
  tlsKeyUse: EntityFieldOption!

  """The tlsKeystoreId of the http configuration"""
  tlsKeystoreId: String

  """The tlsKeyAlias of the http configuration"""
  tlsKeyAlias: String

  """The tlsCipherSuites of the http configuration"""
  tlsCipherSuites: [String!]

  """The connectTimeout of the http configuration"""
  connectTimeout: Int

  """The readTimeout of the http configuration"""
  readTimeout: Int

  """The followRedirects of the http configuration"""
  followRedirects: Boolean

  """The proxyUse of the http configuration"""
  proxyUse: EntityFieldOption!

  """The HttpProxyConfiguration of the http configuration"""
  proxyConfiguration: HttpProxyConfiguration
}

input HttpConfigurationInput {
  """The goid for the http configuration"""
  goid: ID

  """The host of the http configuration"""
  host: String!

  """The port of the http configuration"""
  port: Int = 0

  """The protocol of the http configuration"""
  protocol: HttpScheme = ANY

  """The path of the http configuration"""
  path: String

  """The username of the http configuration"""
  username: String

  """The securePasswordName of the http configuration"""
  securePasswordName: String

  """The ntlmHost of the http configuration"""
  ntlmHost: String

  """The ntlmDomain of the http configuration"""
  ntlmDomain: String

  """The tlsVersion of the http configuration"""
  tlsVersion: String

  """The tlsKeyUse of the http configuration"""
  tlsKeyUse: EntityFieldOption = DEFAULT

  """The tlsKeystoreId of the http configuration"""
  tlsKeystoreId: String = "00000000000000000000000000000000"

  """The tlsKeyAlias of the http configuration"""
  tlsKeyAlias: String

  """The tlsCipherSuites of the http configuration"""
  tlsCipherSuites: [String!]

  """The connectTimeout of the http configuration"""
  connectTimeout: Int

  """The readTimeout of the http configuration"""
  readTimeout: Int

  """The followRedirects of the http configuration"""
  followRedirects: Boolean

  """The proxyUse of the http configuration"""
  proxyUse: EntityFieldOption = DEFAULT

  """The HttpProxyConfiguration of the http configuration"""
  proxyConfiguration: HttpProxyConfigurationInput

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input HttpConfigurationPartialInput {
  """The goid for the http configuration"""
  goid: ID

  """The host of the http configuration"""
  host: String!

  """The port of the http configuration"""
  port: Int = 0

  """The protocol of the http configuration"""
  protocol: HttpScheme = ANY

  """The path of the http configuration"""
  path: String
}

type HttpConfigurationsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  httpConfigurations: [HttpConfiguration]!
}

"""Support Http methods for Web API Service"""
enum HttpMethod {
  DELETE
  HEAD
  GET
  POST
  PUT
  OPTIONS
  PATCH
  OTHER
}

type HttpProxyConfiguration {
  """The proxyHost of the http proxy configuration"""
  host: String

  """The proxyPort of the http proxy configuration"""
  port: Int

  """The proxyUsername of the http proxy configuration"""
  username: String

  """The securePasswordName of the http proxy configuration"""
  securePasswordName: String
}

input HttpProxyConfigurationInput {
  """The proxyHost of the http proxy configuration"""
  host: String!

  """The proxyPort of the http proxy configuration"""
  port: Int!

  """The proxyUsername of the http proxy configuration"""
  username: String

  """The securePasswordName of the http proxy configuration"""
  securePasswordName: String
}

enum HttpScheme {
  HTTP
  HTTPS
  ANY
}

""" Indicate how to search for group or user. Provide either a name pattern, a subject dn and or a goid. 
"""
input IdpFilter {
  """ The name of the FiP provider, or 'Internal' """
  providerName: String!

  """
  Finds users and groups whose name matches the specified pattern. May include wildcard such as * character
  """
  namePattern: String

  """ SubjectDN of a FIP user """
  subjectDn: String

  """ Get entity by goid """
  goid: ID
}

""" A group of users defined in the internal identity provider """
type InternalGroup {
  goid: ID!
  name: String!

  """
  A checksum of the name, description and member names properties of the group
  """
  checksum: String!
  description: String

  """ The list of internal users that are part of this group """
  members: [InternalUser!]!
}

input InternalGroupInput {
  name: String!

  """If provided, will try to honour at creation time"""
  goid: ID
  description: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type InternalGroupsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalGroups: [InternalGroup]!
}

type InternalSearchResult {
  internalUsers: [InternalUser!]!
  internalGroups: [InternalGroup!]!
}

"""A Soap service published on the Layer7 Gateway"""
type InternalSoapService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String

  """Soap service resolvers"""
  resolvers: SoapResolvers!

  """The configuration checksum"""
  checksum: String!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """The folder path to the service"""
  folderPath: String!

  """Which SOAP version"""
  soapVersion: SoapVersion!

  """Which http methods are allowed if not just POST"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean
  properties: [EntityProperty!]

  """The WSDL of the soap service"""
  wsdl: String!

  """The policy and dependencies"""
  policy: Policy!
}

type InternalSoapServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalSoapServices: [InternalSoapService]!
}

""" A user in the internal identity provider """
type InternalUser {
  goid: ID!
  name: String
  login: String!
  checksum: String!
  enabled: Boolean!

  """The hashed password of the user if defined"""
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String

  """ List of groups this is member of """
  memberOf: [InternalGroup!]!
}

input InternalUserInput {
  name: String

  """If provided, will try to honour at creation time"""
  goid: ID

  """
  The list of internal group details (names) that this user is member of. If you
  pass empty array, will reset memberships. If absent, does not affect
  memberships for current users.
  """
  memberOf: [MembershipInput!]
  login: String!

  """
  You can either pass in the hashed password which comes back in queries or the raw passwd directly
  """
  password: String

  """
  A client-side certificate associated with this user to use for pki type authentication
  """
  certBase64: String
  firstName: String
  lastName: String
  email: String

  """Is user enabled or not!"""
  enabled: Boolean

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type InternalUsersPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalUsers: [InternalUser]!
}

"""A Internal Web API service published on the Layer7 Gateway"""
type InternalWebApiService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String!

  """The configuration checksum"""
  checksum: String!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """The folder path to the service"""
  folderPath: String!

  """Which http methods are allowed"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!
  properties: [EntityProperty!]

  """The policy and dependencies"""
  policy: Policy!
}

type InternalWebApiServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  internalWebApiServices: [InternalWebApiService]!
}

"""A JDBC Connection"""
type JdbcConnection {
  """The goid for the JDBC Connection"""
  goid: ID!

  """The JDBC Connection name"""
  name: String!

  """The configuration checksum of this JDBC connection"""
  checksum: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """The username"""
  username: String!

  """The password or the secure password reference."""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt!

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt!

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityProperty!]
}

input JdbcConnectionInput {
  """The internal entity unique identifier"""
  goid: ID

  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String!

  """The JDBC url"""
  jdbcUrl: String!

  """Whether this JDBC connection is enabled"""
  enabled: Boolean! = true

  """The username"""
  username: String!

  """The password or the secured password reference"""
  password: String!

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt! = 3

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt! = 15

  """The JDBC connection properties excluding 'user' and 'password'"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

input JdbcConnectionPartialInput {
  """The JDBC Connection name"""
  name: String!

  """The JDBC driver class name"""
  driverClass: String

  """The JDBC url"""
  jdbcUrl: String

  """Whether this JDBC connection is enabled"""
  enabled: Boolean

  """The username"""
  username: String

  """The password or the secured password reference"""
  password: String

  """The minimum connection pool size"""
  minPoolSize: NonNegativeInt

  """The maximum connection pool size"""
  maxPoolSize: PositiveInt

  """
  The JDBC connection properties excluding 'user' and 'password'.  When specified, will replace all existing properties
  """
  properties: [EntityPropertyInput!]
}

type JdbcConnectionPayload implements EntityMutationPayload {
  status: EntityMutationStatus!
  detailedStatus: EntityMutationDetailedStatus!

  """The created JDBC connection."""
  jdbcConnection: JdbcConnection
}

type JdbcConnectionsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created/updated JDBC connections."""
  jdbcConnections: [JdbcConnection]!
}

"""A JMS Destination"""
type JmsDestination {
  """The goid for the JMS Destination"""
  goid: ID!

  """The goid for the JMS Connection"""
  connectionGoid: ID!

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (INBOUND or OUTBOUND)"""
  direction: String!

  """
  The JMS provider type (GENERIC JMS or TIBCO EMS or WEBSPHERE MQ OVER LDAP or WEBLOGIC JMS
  """
  providerType: String!

  """The configuration checksum of this JMS destination"""
  checksum: String!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """Whether this JMS destination is template"""
  template: Boolean!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetails!

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetails!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityProperty!]
}

input JmsDestinationInput {
  """The internal entity unique identifier"""
  goid: ID
  connectionGoid: ID

  """The JMS Destination name"""
  name: String!

  """The JMS Destination direction (inbound or outbound)"""
  direction: String!

  """The JMS provider type"""
  providerType: String!

  """The initial context factory class name"""
  initialContextFactoryClassname: String!

  """The connection factory name"""
  connectionFactoryName: String!

  """The JNDI URL"""
  jndiUrl: String!

  """The JNDI username"""
  jndiUsername: String

  """The JNDI password"""
  jndiPassword: String

  """The JNDI SSL details"""
  jndiSslDetails: JmsSslDetailsInput

  """The destination type"""
  destinationType: String!

  """The destination name"""
  destinationName: String!

  """The username for destination connection"""
  destinationUsername: String

  """The password for destination connection"""
  destinationPassword: String

  """The destination SSL details"""
  destinationSslDetails: JmsSslDetailsInput

  """Whether this JMS destination is template"""
  template: Boolean!

  """Whether this JMS destination is enabled"""
  enabled: Boolean!

  """
  The remaining JMS Destination properties that include inbound options or outbound options or additional properties
  """
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type JmsDestinationsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created/updated JMS destinations."""
  jmsDestinations: [JmsDestination]!
}

"""A JMS SSL Details"""
type JmsSslDetails {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

input JmsSslDetailsInput {
  """Whether SSL is enabled"""
  sslEnabled: Boolean!

  """Whether SSL is used for Authentication only"""
  sslForAuthenticationOnly: Boolean!

  """Whether SSL Server Certificate is to be verified"""
  sslVerifyServerCertificate: Boolean!

  """Whether SSL Server Hostname is to be verified"""
  sslVerifyServerHostname: Boolean!

  """Private Key Alias for SSL Client Authentication"""
  sslClientKeyAlias: String
}

"""Defines a current status of a given scheduled task"""
enum JobStatus {
  SCHEDULED
  COMPLETED
  DISABLED
}

"""Defines a scheduled task type"""
enum JobType {
  ONE_TIME
  RECURRING
}

"""
This is an entry in the gateway keystore. These entries combine a private
key and associated certificate and are used for example by listener ports
These represent the gateway's own certificates as opposed to the Certificate
type which represent a cert trusted by the gateway.
"""
type Key {
  """The internal entity unique identifier"""
  goid: ID!

  """The gateway keystore identifier"""
  keystoreId: ID!

  """The name assigned to the key"""
  alias: String!

  """The configuration checksum"""
  checksum: String!

  """The type of the private key"""
  keyType: String!

  """The Key usage types"""
  usageTypes: [KeyUsageType!]

  """The subjectDN"""
  subjectDn: String!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String

  """The private key data in PEM format"""
  pem: String

  """The certificate chain in PEM format"""
  certChain: [String!]
}

input KeyInput {
  keystoreId: ID = "00000000000000000000000000000002"
  alias: String!

  """
  Base64 encoded PKCS12 keystore containing the private key and cert chain for the key entry.
  The keystore is password-protected using the transaction encryption passphrase provided.
  """
  p12: String

  """The private key data in PEM format"""
  pem: String

  """Will try to match at creation time is specified"""
  goid: ID

  """
  SubjectDn of the certificate associated with the key. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """Key type. (Note that, this field has no effect on the mutation)"""
  keyType: String

  """
  The Key usage types. (Note that, the key usage will not be reset when this field is not specified)
  """
  usageTypes: [KeyUsageType!]

  """
  The certificate chain in PEM format. (Note that, this field has no effect on the mutation)
  """
  certChain: [String!]

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String
}

type KeysPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  keys: [Key]!
}

enum KeyUsageType {
  """Represents a key marked as the default SSL key"""
  SSL

  """Represents a key marked as the default CA key"""
  CA

  """Represents a key marked as the default audit viewer/decryption key"""
  AUDIT_VIEWER

  """Represents a key marked as the default audit signing key"""
  AUDIT_SIGNING
}

"""
LdapIdp config itself is provided. Graphman wont get to
underlying users and groups in the ldap since they are not
part of the gateway configuration itself. When l7 policies
refer to these ldap users and groups, thee references are
interpreted by the ldap directory itself.
"""
type Ldap {
  goid: ID!
  name: String!
  checksum: String!
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """The ID of the gateway keystore where the key is located"""
  ldapsClientKeystoreId: ID

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMapping!]!
  groupMappings: [GroupMapping!]!
}

input LdapInput {
  name: String!

  """Will try to match goid if provided"""
  goid: ID
  ldapUrls: [String!]!

  """
  Whether or not the gateway presents a client cert when connecting at those ldap urls (only relevant when ldaps url)
  """
  ldapsClientAuthEnabled: Boolean!

  """The ID of the gateway keystore where the key is located"""
  ldapsClientKeystoreId: ID

  """
  The alias of the key in the gateway keystore that is used when doing ldaps client cert authentication
  """
  ldapsClientKeyAlias: String
  searchBase: String!
  writable: Boolean!
  bindDn: String!
  bindPassword: String!
  userMappings: [UserMappingInput!]!
  groupMappings: [GroupMappingInput!]!

  """
  The optional checksum is ignored during the mutation but can be used to compare bundle content
  """
  checksum: String
}

type LdapsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  ldaps: [Ldap]!
}

type ListenPort {
  """The internal entity unique identifier"""
  goid: ID!

  """The listen port configuration name"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """Whether this listen port configuration is enabled"""
  enabled: Boolean!

  """
  Protocol (scheme). Possible values are:
      HTTP
      HTTPS
      HTTP2
      HTTP2 (Secure)
      FTP
      FTPS
      l7.raw.tcp
      SSH2
  """
  protocol: String!

  """
  The ListenPort's port number
  Note: If the listen port is using the SSH2 protocol, avoid using port 22, as
  it may conflict with the default SSH port 22 on Linux or Unix systems.
  """
  port: PositiveInt!

  """The name of the published service hardwired to the listen port"""
  hardwiredServiceName: String

  """Which Gateway services can be accessed through this listen port"""
  enabledFeatures: [ListenPortFeature!]!

  """The listen port tls settings"""
  tlsSettings: ListenPortTlsSettings

  """The listen port properties"""
  properties: [EntityProperty!]

  """The published service hardwired to the listen port"""
  hardwiredService: HardwiredService
}

enum ListenPortClientAuth {
  NONE
  OPTIONAL
  REQUIRED
}

enum ListenPortFeature {
  PUBLISHED_SERVICE_MESSAGE_INPUT
  POLICY_MANAGER_ACCESS
  ENTERPRISE_MANAGER_ACCESS
  ADMINISTRATIVE_ACCESS
  BROWSER_BASED_ADMINISTRATION
  POLICY_DOWNLOAD_SERVICE
  PING_SERVICE
  WS_TRUST_SECURITY_TOKEN_SERVICE
  CERTIFICATE_SIGNING_SERVICE
  PASSWORD_CHANGING_SERVICE
  WSDL_DOWNLOAD_SERVICE
  SNMP_QUERY_SERVICE
  BUILT_IN_SERVICES
  NODE_CONTROL
  INTER_NODE_COMMUNICATION
}

input ListenPortInput {
  """The internal entity unique identifier"""
  goid: ID

  """The listen port configuration name"""
  name: String!

  """
  Whether this listen port configuration is enabled to listen for traffic on the specified port
  """
  enabled: Boolean!

  """
  Protocol (scheme). Possible values are:
  HTTP
  HTTPS
  HTTP2
  HTTP2 (Secure)
  FTP
  FTPS
  l7.raw.tcp
  SSH2
  """
  protocol: String!

  """
  The ListenPort's port number
  Note: If the listen port is using the SSH2 protocol, avoid using port 22, as
  it may conflict with the default SSH port 22 on Linux or Unix systems.
  """
  port: PositiveInt!

  """The name of the published service hardwired to the listen port"""
  hardwiredServiceName: String

  """Which Gateway services can be accessed through this listen port"""
  enabledFeatures: [ListenPortFeature!]!

  """The listen port tls settings"""
  tlsSettings: ListenPortTlsSettingsInput

  """The listen port properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ListenPortsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  listenPorts: [ListenPort]!
}

type ListenPortTlsSettings {
  """
  Specify whether the client must present a certificate to authenticate: NONE/OPTIONAL/REQUIRED
  """
  clientAuthentication: ListenPortClientAuth!

  """Keystore ID"""
  keystoreId: ID

  """Key alias configured for listen port"""
  keyAlias: String

  """TLS versions to be enabled for the listen port"""
  tlsVersions: [String!]!

  """Cipher suites that will be enabled on the SSL listen port"""
  cipherSuites: [String!]

  """Enforces cipher suites usage in the order of preference"""
  useCipherSuitesOrder: Boolean!
}

input ListenPortTlsSettingsInput {
  """
  Specify whether the client must present a certificate to authenticate: NONE/OPTIONAL/REQUIRED
  """
  clientAuthentication: ListenPortClientAuth!

  """Keystore ID"""
  keystoreId: ID

  """Key alias configured for listen port"""
  keyAlias: String

  """TLS versions to be enabled for the listen port"""
  tlsVersions: [String!]!

  """Cipher suites that will be enabled on the SSL listen port"""
  cipherSuites: [String!]

  """Enforces cipher suites usage in the order of preference"""
  useCipherSuitesOrder: Boolean!
}

"""Indicates severity threshold of the log sink"""
enum LogSeverityThreshold {
  ALL
  FINEST
  FINER
  FINE
  CONFIG
  INFO
  WARNING
  SEVERE
}

type LogSink {
  """The internal entity unique identifier"""
  goid: ID!

  """log sink unique name"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """description of log sink"""
  description: String

  """defines whether its a file based log Or sysLog"""
  type: LogSinkType!

  """Whether this log sink is enabled"""
  enabled: Boolean!

  """defines the severity threshold of log Sink"""
  severity: LogSeverityThreshold!

  """defines list of categories"""
  categories: [LogSinkCategory!]!

  """defines syslog host list"""
  syslogHosts: [String!]

  """defines list of Log sink filters"""
  filters: [LogSinkFilter!]

  """defines list of log Sink properties"""
  properties: [EntityProperty!]!
}

"""Indicates the Sink Category"""
enum LogSinkCategory {
  LOG
  TRAFFIC
  AUDIT
  SSPC
}

"""Indicate the long sink filter, consist of a type and list of values"""
type LogSinkFilter {
  """defines the type of log sink"""
  type: String!

  """defines the list of values"""
  values: [String!]!
}

"""Indicate the long sink filter, consist of a type and list of values"""
input LogSinkFilterInput {
  """defines the type of log sink"""
  type: String!

  """defines the list of values"""
  values: [String!]!
}

input LogSinkInput {
  """The internal entity unique identifier"""
  goid: ID

  """log sink unique name"""
  name: String!

  """description of log sink"""
  description: String

  """defines whether its a file based log or sysLog"""
  type: LogSinkType!

  """Whether this log sink is enabled"""
  enabled: Boolean!

  """defines the severity threshold of log Sink"""
  severity: LogSeverityThreshold!

  """defines list of categories"""
  categories: [LogSinkCategory!]!

  """defines syslog host list"""
  syslogHosts: [String!]

  """defines list of Log sink filters"""
  filters: [LogSinkFilterInput!]

  """defines list of log Sink properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type LogSinksPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  logSinks: [LogSink]!
}

"""Indicates the type of sink . File Based Or SYSLOG based"""
enum LogSinkType {
  FILE
  SYSLOG
}

input MembershipInput {
  """The name of group to which the membership is defined"""
  name: String!
  goid: ID
  description: String
  providerName: String
  checksum: String
}

type MemberStrategy {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

input MemberStrategyInput {
  """
  Possible values are 0 for MEMBERS_ARE_DN, 1 MEMBERS_ARE_LOGIN, 2 MEMBERS_ARE_NVPAIR, 3 MEMBERS_BY_OU
  """
  val: Int!
}

enum ModuleState {
  UPLOADED
  ACCEPTED
  REJECTED
  LOADED
  ERROR
}

enum ModuleStateSummary {
  LOADING
  LOADED
  ERROR
}

enum ModuleType {
  MODULAR_ASSERTION
  CUSTOM_ASSERTION
}

type Mutation {
  """Installs bundle of entities using set-based mutation operations"""
  installBundleEntities: BundleEntitiesPayload

  """Deletes bundle of entities using set-based mutation operations"""
  deleteBundleEntities: BundleEntitiesPayload

  """Create or update policy fragments"""
  setPolicyFragments(input: [PolicyFragmentInput!]!): PolicyFragmentsPayload!

  """Delete policy fragments"""
  deletePolicyFragments(names: [String!]!): PolicyFragmentsPayload!

  """Create or update global policies"""
  setGlobalPolicies(input: [GlobalPolicyInput!]!): GlobalPoliciesPayload!

  """Delete global policies"""
  deleteGlobalPolicies(tags: [String!]!): GlobalPoliciesPayload!

  """Create or update web api services"""
  setWebApiServices(input: [WebApiServiceInput!]!): WebApiServicesPayload

  """Create or update Internal web api services"""
  setInternalWebApiServices(input: [WebApiServiceInput!]!): InternalWebApiServicesPayload

  """Delete existing web api services given their resolution paths"""
  deleteWebApiServices(resolutionPaths: [String!]!): WebApiServicesPayload

  """Delete existing Internal web api services given their resolution paths"""
  deleteInternalWebApiServices(resolutionPaths: [String!]!): InternalWebApiServicesPayload

  """Create or update soap services"""
  setSoapServices(input: [SoapServiceInput!]!): SoapServicesPayload

  """Create or update Internal soap services"""
  setInternalSoapServices(input: [SoapServiceInput!]!): InternalSoapServicesPayload

  """Delete existing soap services given their resolution details"""
  deleteSoapServices(resolvers: [SoapServiceResolverInput!]!): SoapServicesPayload

  """Delete existing Internal soap services given their resolution details"""
  deleteInternalSoapServices(resolvers: [SoapServiceResolverInput!]!): InternalSoapServicesPayload

  """Create or update Encapsulated Assertion Configurations"""
  setEncassConfigs(input: [EncassConfigInput!]!): EncassConfigsPayload

  """Delete existing Encapsulated Assertion Configurations"""
  deleteEncassConfigs(names: [String!]!): EncassConfigsPayload

  """
  Create or update existing custom key values data.  If a custom key value with the given key does not
  exist, one will be created, otherwise the existing one will be updated. This returns the list of
  entities created and/or updated
  """
  setCustomKeyValues(input: [CustomKeyValueInput!]!): CustomKeyValuePayload!

  """Delete existing cluster properties"""
  deleteCustomKeyValues(keys: [String!]!): CustomKeyValuePayload!

  """
  Create or update existing cluster properties.  If a cluster property with the given name does not
  exist, one will be created, otherwise the existing one will be updated. This returns the list of
  entities created and/or updated
  """
  setClusterProperties(input: [ClusterPropertyInput!]!): ClusterPropertiesPayload!

  """Delete existing cluster properties"""
  deleteClusterProperties(names: [String!]!): ClusterPropertiesPayload!

  """
  Create or update trusted certificates.
  If a certificate with the same sha1 thumbprint already exist, it will be updated.
  """
  setTrustedCerts(input: [TrustedCertInput!]!): TrustedCertsPayload!

  """Delete an existing certificates"""
  deleteTrustedCerts(thumbprintSha1s: [String!]!): TrustedCertsPayload!

  """
  Create a JDBC connection.
  If a JDBC connection with the same name already exists, the creation will fail.
  NOTE: This is experimental method, likely to be removed or revised in future.
  """
  createJdbcConnection(input: JdbcConnectionInput!): JdbcConnectionPayload!

  """
  Update an existing JDBC connection.
  If no JDBC connection with the same name exist, the update will fail
  NOTE: This is experimental method, likely to be removed or revised in future.
  """
  updateJdbcConnection(input: JdbcConnectionPartialInput!): JdbcConnectionPayload!

  """
  Create or update JDBC connections.
  If JDBC connection with the same name exist, the JDBC connection will be updated.
  If no JDBC connection with the name exist, a new JDBC connection will be created.
  """
  setJdbcConnections(input: [JdbcConnectionInput!]!): JdbcConnectionsPayload!

  """Deletes JDBC connections."""
  deleteJdbcConnections(
    """The names of the JDBC connection to delete"""
    names: [String!]!
  ): JdbcConnectionsPayload

  """
  Create or update Cassandra connections.
  If Cassandra connection with the same name exist, the Cassandra connection will be updated.
  If no Cassandra connection with the name exist, a new Cassandra connection will be created.
  """
  setCassandraConnections(input: [CassandraConnectionInput!]!): CassandraConnectionsPayload!

  """Deletes Cassandra connections."""
  deleteCassandraConnections(
    """The names of the Cassandra connection to delete"""
    names: [String!]!
  ): CassandraConnectionsPayload!

  """
  Create or update JMS destinations.
  If JMS destination exists, the JMS destination will be updated.
  If no JMS destination with given name, direction, providerType exist, a new JMS destination will be created.
  """
  setJmsDestinations(input: [JmsDestinationInput!]!): JmsDestinationsPayload!

  """
  Deletes JMS destinations. Use simple name or fully qualified name of JMS destinations to delete.
  """
  deleteJmsDestinations(names: [String!]!): JmsDestinationsPayload

  """Create or Update multiple XML schemas"""
  setSchemas(input: [SchemaInput!]!): SchemasPayload

  """Delete multiple XML schemas"""
  deleteSchemas(systemIds: [String!]!): SchemasPayload

  """Create or Update multiple DTD resources"""
  setDtds(input: [DtdInput!]!): DtdsPayload

  """Delete multiple DTD resources"""
  deleteDtds(systemIds: [String!]!): DtdsPayload

  """Creates or updates one or more fips"""
  setFips(input: [FipInput!]!): FipsPayload

  """Creates or updates one or more ldaps"""
  setLdaps(input: [LdapInput!]!): LdapsPayload

  """Deletes one or more existing fips"""
  deleteFips(names: [String!]!): FipsPayload

  """Deletes one or more existing ldaps"""
  deleteLdaps(names: [String!]!): LdapsPayload

  """Creates or updates one or more internal users"""
  setInternalUsers(input: [InternalUserInput!]!): InternalUsersPayload

  """Creates or updates one or more internal groups"""
  setInternalGroups(input: [InternalGroupInput!]!): InternalGroupsPayload

  """Deletes one or more existing internal users"""
  deleteInternalUsers(logins: [String!]!): InternalUsersPayload

  """Deletes one or more existing internal groups"""
  deleteInternalGroups(names: [String!]!): InternalGroupsPayload

  """
  Creates or updates one or more fip users.
  NOTE: Existing user will be found by either login or subjectDn or name.
  """
  setFipUsers(input: [FipUserInput!]!): FipUsersPayload

  """Creates or updates one or more fip groups"""
  setFipGroups(input: [FipGroupInput!]!): FipGroupsPayload

  """
  Deletes one or more existing fip users.
  NOTE: Here, name can be either login or subjectDn or name.
  """
  deleteFipUsers(providerName: String!, names: [String!]!): FipUsersPayload

  """Deletes one or more existing fip groups"""
  deleteFipGroups(providerName: String!, names: [String!]!): FipGroupsPayload

  """Creates or updates one or more secrets"""
  setSecrets(input: [SecretInput!]!): SecretsPayload

  """Creates or updates one or more keys"""
  setKeys(input: [KeyInput!]!): KeysPayload

  """Deletes one or more existing secrets"""
  deleteSecrets(names: [String!]!): SecretsPayload

  """Deletes one or more existing keys"""
  deleteKeys(aliases: [String!]!): KeysPayload

  """
  Sets Server module files. Updating the existing server module file is unsupported.
  """
  setServerModuleFiles(input: [ServerModuleFileInput!]!): ServerModuleFilesPayload

  """Deletes Server module files."""
  deleteServerModuleFiles(
    """The names of the Server module file to delete"""
    names: [String!]!
  ): ServerModuleFilesPayload

  """Creates or updates one or more scheduled tasks"""
  setScheduledTasks(input: [ScheduledTaskInput!]!): ScheduledTasksPayload!

  """Creates or updates one or more background task policies"""
  setBackgroundTaskPolicies(input: [BackgroundTaskPolicyInput!]!): BackgroundTaskPoliciesPayload!

  """Deletes one or more existing scheduled tasks"""
  deleteScheduledTasks(names: [String!]!): ScheduledTasksPayload!

  """Deletes an existing background task policy"""
  deleteBackgroundTaskPolicies(names: [String!]!): BackgroundTaskPoliciesPayload!

  """
  Create or update existing email listeners.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created.
  """
  setEmailListeners(input: [EmailListenerInput!]!): EmailListenersPayload!

  """Delete existing email listeners. Match is carried by name."""
  deleteEmailListeners(names: [String!]!): EmailListenersPayload!

  """
  Create or update Listen Ports.
  If Listen Port with the same name exist, the Listen Port will be updated.
  If no Listen Port with the name exist, a new Listen Port will be created.
  """
  setListenPorts(input: [ListenPortInput!]!): ListenPortsPayload!

  """Delete existing listen ports. Match is carried by name."""
  deleteListenPorts(names: [String!]!): ListenPortsPayload!

  """
  Create or update existing active connector.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created.
  """
  setActiveConnectors(input: [ActiveConnectorInput!]!): ActiveConnectorsPayload!

  """Delete existing active connector. Match is carried by name."""
  deleteActiveConnectors(names: [String!]!): ActiveConnectorsPayload!

  """
  Create or update existing siteminder configurations.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created
  """
  setSMConfigs(input: [SMConfigInput!]!): SMConfigsPayload!

  """Delete existing siteminder configurations. Match is carried by name"""
  deleteSMConfigs(names: [String!]!): SMConfigsPayload!

  """Update Service Resolution Configs"""
  setServiceResolutionConfigs(input: [ServiceResolutionConfigInput!]!): ServiceResolutionConfigsPayLoad!

  """Set/Update the Password Policies"""
  setPasswordPolicies(input: [PasswordPolicyInput!]!): PasswordPoliciesPayLoad!

  """
  Create or update existing revocation check policies.
  Match is carried by name. If match is found, it will be updated. Otherwise, it will be created.
  """
  setRevocationCheckPolicies(input: [RevocationCheckPolicyInput!]!): RevocationCheckPoliciesPayload!

  """Delete existing revocation policies. Match is carried by name."""
  deleteRevocationCheckPolicies(names: [String!]!): RevocationCheckPoliciesPayload!

  """
  Create or update existing Administrative User Account Minimum cluster properties.
  If Administrative User Account Minimum cluster property with the given name
  does not exist, one will be created, otherwise the existing one will be updated.
  This returns the list of entities created and/or updated.
  Below are the allowed Administrative User Account Minimum properties
  logonMaxAllowableAttempts : Logon attempts must be between 1 and 20
  logonLockoutTime : Lockout period must be between 1 and 86400 seconds
  logonSessionExpiry : Expiry period must be between 1 and 86400 seconds
  logonInactivityPeriod : Inactivity period must be between 1 and 365 days
  """
  setAdministrativeUserAccountProperties(input: [AdministrativeUserAccountPropertyInput!]!): AdministrativeUserAccountPropertiesPayload!

  """Create or update existing http configuration."""
  setHttpConfigurations(input: [HttpConfigurationInput!]!): HttpConfigurationsPayload!

  """Delete existing http configuration"""
  deleteHttpConfigurations(input: [HttpConfigurationPartialInput!]!): HttpConfigurationsPayload!

  """Set the Folders"""
  setFolders(input: [FolderInput!]!): FoldersPayload!

  """Delete the Folders by Path"""
  deleteFolders(paths: [String!]!): FoldersPayload!

  """
  Create or update Log Sinks.
  If Log Sink with the same name exist, the Log Sink will be updated.
  If no Log Sink with the name exist, a new Log Sink will be created.
  """
  setLogSinks(input: [LogSinkInput!]!): LogSinksPayload!

  """Delete existing log sinks. Match is carried by name."""
  deleteLogSinks(names: [String!]!): LogSinksPayload!
}

"""A String scalar that must be a non empty value"""
scalar NonEmptyString

"""An Integer that MUST be greater than or equal to zero"""
scalar NonNegativeInt

enum OcspNonceUsage {
  """To include nonce in OCSP requests"""
  INCLUDE_NONCE

  """Do not include nonce in OCSP requests"""
  EXCLUDE_NONCE

  """Let pkix.ocsp.useNonce cluster wide property decide"""
  USE_NONCE_CONDITIONALLY
}

type PasswdStrategy {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

input PasswdStrategyInput {
  """Possible values are 0 for CLEAR, 1 for HASHED"""
  val: Int!
}

type PasswordPoliciesPayLoad {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  passwordPolicies: [PasswordPolicy]!
}

type PasswordPolicy {
  """The internal entity unique identifier"""
  goid: ID!

  """The configuration checksum"""
  checksum: String!

  """Force password change for new user and reset"""
  forcePasswordChangeNewUser: Boolean!

  """To enable/disable no repeating characters"""
  noRepeatingCharacters: Boolean!

  """
  Minimum Password Length - Enter the minimum number of characters ranging from 3 to 128 required for the password.
  """
  minPasswordLength: Int!

  """
  Maximum Password Length - Enter the maximum number of characters ranging from 3 to 128 required for the password.
  """
  maxPasswordLength: Int!

  """
  Set the number of uppercase letters that are required for the password. ranging from 1 to 128
  """
  upperMinimum: Int!

  """
  Set the number of lowercase letters that are required for the password. ranging from 1 to 128
  """
  lowerMinimum: Int!

  """
  Sets how many numbers (0-9) are required for the password. ranging from 1 to 128
  """
  numberMinimum: Int!

  """
  Sets how many symbol characters are required for the password. ranging from 1 to 128
  """
  symbolMinimum: Int!

  """
  Sets how many non numeric characters are required for the password. ranging from 1 to 128
  """
  nonNumericMinimum: Int!

  """
  Sets how many characters are required for the password. ranging from 1 to 128
  """
  charDiffMinimum: Int!

  """
  Enter the number of times, between 1 and 50, that a new password must be different from the current password
  """
  repeatFrequency: Int!

  """Days required for the password to be expired. ranging from 1 to 1825"""
  passwordExpiry: Int!

  """Allow One Password Change Per 24 Hours"""
  allowableChangesPerDay: Boolean!
}

input PasswordPolicyInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String

  """Force password change for new user and reset"""
  forcePasswordChangeNewUser: Boolean!

  """To enable/disable no repeating characters"""
  noRepeatingCharacters: Boolean!

  """
  Minimum Password Length - Enter the minimum number of characters ranging from 3 to 128 required for the password.
  """
  minPasswordLength: Int!

  """
  Maximum Password Length - Enter the maximum number of characters ranging from 3 to 128 required for the password.
  """
  maxPasswordLength: Int! = 32

  """
  Set the number of uppercase letters that are required for the password. ranging from 1 to 128
  """
  upperMinimum: Int! = 1

  """
  Set the number of lowercase letters that are required for the password. ranging from 1 to 128
  """
  lowerMinimum: Int! = 1

  """
  Sets how many numbers (0-9) are required for the password. ranging from 1 to 128
  """
  numberMinimum: Int! = 1

  """
  Sets how many symbol characters are required for the password. ranging from 1 to 128
  """
  symbolMinimum: Int! = 1

  """
  Sets how many non numeric characters are required for the password. ranging from 1 to 128
  """
  nonNumericMinimum: Int! = -1

  """
  Sets how many characters are required for the password. ranging from 1 to 128
  """
  charDiffMinimum: Int! = 4

  """
  Enter the number of times, between 1 and 50, that a new password must be different from the current password
  """
  repeatFrequency: Int! = 10

  """Days required for the password to be expired. ranging from 1 to 1825"""
  passwordExpiry: Int! = 90

  """Allow One Password Change Per 24 Hours"""
  allowableChangesPerDay: Boolean!
}

"""Wrapper for the policy XML and the dependencies they include"""
type Policy {
  """The policy XML"""
  xml: String!

  """Entities that are directly referred to inside the policy XML"""
  directDependencies: PolicyDependency

  """
  Entities that are directly referred to inside the policy XML in addition to
  ones in policy dependencies. More than second level, this keep going as deep
  as needed until no dependencies are found
  """
  allDependencies: PolicyDependency
}

"""
Policy Dependency contains all dependencies that may be referred to from the policy XML this is associated with
"""
type PolicyDependency {
  """Active Connectors (SFTP, MQ Native, Kafka)"""
  activeConnectors: [ActiveConnector]

  """Cassandra connections"""
  cassandraConnections: [CassandraConnection]

  """Cluster properties"""
  clusterProperties: [ClusterProperty]

  """Custom key values"""
  customKeyValues: [CustomKeyValue]

  """DTDs in global resources"""
  dtds: [Dtd]

  """Email Listeners"""
  emailListeners: [EmailListener]

  """Encass Configs"""
  encassConfigs: [EncassConfig]

  """Federated identity provider configurations"""
  fips: [Fip]

  """Federated identity provider groups"""
  fipGroups: [FipGroup]

  """Federated identity provider users"""
  fipUsers: [FipUser]

  """Internal idp groups"""
  internalGroups: [InternalGroup]

  """Internal idp users"""
  internalUsers: [InternalUser]

  """JDBC connections"""
  jdbcConnections: [JdbcConnection]

  """JMS destinations"""
  jmsDestinations: [JmsDestination]

  """Private Keys"""
  keys: [Key]

  """Ldap identity provider configurations"""
  ldaps: [Ldap]

  """Listen Ports"""
  listenPorts: [ListenPort]

  """Policy Fragments"""
  policyFragments: [PolicyFragment]

  """Revocation Check Polices"""
  revocationCheckPolicies: [RevocationCheckPolicy]

  """Schemas in global resources"""
  schemas: [Schema]
  secrets: [Secret]

  """Server module files (signed modular or custom assertions)"""
  serverModuleFiles: [ServerModuleFile]

  """Siteminder Configurations"""
  smConfigs: [SMConfig]

  """Trusted certificates"""
  trustedCerts: [Certificate]
}

"""A policy fragment that can be included in another policy"""
type PolicyFragment {
  """The goid for this policy"""
  goid: ID!

  """The guid for this policy"""
  guid: ID!

  """The name of the policy (policies are unique by name)"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """The folder path to the policy"""
  folderPath: String!
  soap: Boolean

  """The actual policy and dependencies"""
  policy: Policy!
}

input PolicyFragmentInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  The folder path where to create this policy.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the policy. Policies are unique by name."""
  name: String!

  """The guid for this policy, if none provided, assigned at creation"""
  guid: ID

  """The policy"""
  policy: PolicyInput!
  soap: Boolean = false

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type PolicyFragmentsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  policyFragments: [PolicyFragment]!
}

input PolicyInput {
  """The policy xml"""
  xml: String!
}

enum PolicyUsageType {
  """Do not perform revocation check"""
  NONE

  """Use the default revocation check policy"""
  USE_DEFAULT

  """Use the specified revocation check policy"""
  SPECIFIED
}

"""An Integer that MUST be greater than zero"""
scalar PositiveInt

interface PublishedService {
  """The name of the published service"""
  name: String!

  """The resolution path for published service"""
  resolutionPath: String

  """The folder path for published service"""
  folderPath: String!

  """Which HTTP methods are permitted for incoming requests"""
  methodsAllowed: [HttpMethod!]!

  """Whether published service is enabled"""
  enabled: Boolean!
}

type Query {
  """Get all policy fragments"""
  policyFragments: [PolicyFragment!]!

  """Get policy fragment by name"""
  policyFragmentByName(name: String!): PolicyFragment

  """Get policy fragments inside a folder"""
  policyFragmentsByFolderPath(folderPath: String!): [PolicyFragment!]!

  """Get policy fragment by goid"""
  policyFragmentByGoid(goid: ID!): PolicyFragment

  """Get policy fragment by guid"""
  policyFragmentByGuid(guid: ID!): PolicyFragment

  """Get all global policies"""
  globalPolicies: [GlobalPolicy!]!

  """Get global policy by tag"""
  globalPolicyByTag(tag: String!): GlobalPolicy

  """Get global policies inside a folder"""
  globalPoliciesByFolderPath(folderPath: String!): [GlobalPolicy!]!

  """Get all webApi services"""
  webApiServices: [WebApiService]!
  internalWebApiServices: [InternalWebApiService]!

  """Get webApi services by name"""
  webApiServicesByName(name: String!): [WebApiService!]!

  """Get webApi service by name. Returns none if more than one are found."""
  webApiServiceByName(name: String!): WebApiService

  """Get Internal webApi Service by name"""
  internalWebApiServiceByName(name: String!): InternalWebApiService

  """Get webApi services by resolutionPath"""
  webApiServicesByResolutionPath(resolutionPath: String!): [WebApiService!]!

  """
  Get webApi service by resolutionPath. Returns none if more than one are found.
  """
  webApiServiceByResolutionPath(resolutionPath: String!): WebApiService

  """Get Internal webApi Services by resolutionPath"""
  internalWebApiServiceByResolutionPath(resolutionPath: String!): InternalWebApiService

  """Get webApi services inside a folder"""
  webApiServicesByFolderPath(folderPath: String!): [WebApiService]!

  """Get Internal webApi services inside a folder"""
  internalWebApiServicesByFolderPath(folderPath: String!): [InternalWebApiService]!

  """Get webApi services by goid"""
  webApiServiceByGoid(goid: ID!): WebApiService

  """Get all soap services"""
  soapServices: [SoapService]!

  """Get all Internal soap services"""
  internalSoapServices: [InternalSoapService]!

  """Get soap services by name"""
  soapServicesByName(name: String!): [SoapService]!

  """Get soap service by name. Returns none if more than one are found."""
  soapServiceByName(name: String!): SoapService

  """
  Get Internal soap service by name. Returns none if more than one are found.
  """
  internalSoapServiceByName(name: String!): InternalSoapService

  """Get soap services inside a folder"""
  soapServicesByFolderPath(folderPath: String!): [SoapService]!

  """Get Internal soap services inside a folder"""
  internalSoapServicesByFolderPath(folderPath: String!): [InternalSoapService]!

  """Get soap service by goid"""
  soapServiceByGoid(goid: ID!): SoapService

  """Get soap service by resolver"""
  soapServiceByResolver(resolver: SoapServiceResolverInput!): SoapService

  """Get all Encapsulated Assertion Configurations"""
  encassConfigs: [EncassConfig!]!

  """Get all Encapsulated Assertion Configurations by folder path"""
  encassConfigsByFolderPath(folderPath: String!): [EncassConfig!]!

  """Get Encapsulated Assertion Configuration by name"""
  encassConfigByName(name: String!): EncassConfig

  """Get Encapsulated Assertion Configuration by goid"""
  encassConfigByGoid(goid: ID!): EncassConfig

  """Get Encapsulated Assertion Configuration by guid"""
  encassConfigByGuid(guid: ID!): EncassConfig
  customKeyValues: [CustomKeyValue!]!

  """Get the Custom Key value with the given key name"""
  customKeyValueByKey(key: String!): CustomKeyValue

  """Get all cluster properties"""
  clusterProperties: [ClusterProperty!]!

  """Get the cluster property with the given name"""
  clusterPropertyByName(name: String!): ClusterProperty

  """Retrieves all trusted certificates"""
  trustedCerts: [Certificate!]!

  """Retrieves a list of trusted certificates with the matching subject dn"""
  trustedCertsByDn(subjectDn: String!): [Certificate]!

  """The trusted certificate associated with this unique thumbprint"""
  trustedCertByThumbprint(thumbprintSha1: String!): Certificate

  """Get all JDBC Connections"""
  jdbcConnections: [JdbcConnection!]!

  """Get JDBC Connection by name"""
  jdbcConnectionByName(name: String!): JdbcConnection

  """Get JDBC Connection by goid"""
  jdbcConnectionByGoid(goid: ID!): JdbcConnection

  """Get all Cassandra Connections"""
  cassandraConnections: [CassandraConnection!]!

  """Get Cassandra Connection by name"""
  cassandraConnectionByName(name: String!): CassandraConnection

  """Get Cassandra Connection by goid"""
  cassandraConnectionByGoid(goid: ID!): CassandraConnection

  """Get all JMS Destinations"""
  jmsDestinations: [JmsDestination!]!

  """
  Get JMS Destination by name.
  Here, name can be fully qualified to select JMS destination uniquely.
  Fully qualified name can be composed as: <JMS DIRECTION>.<JMS PROVIDER TYPE>.<NAME>
  """
  jmsDestinationByName(name: String!): JmsDestination

  """
  Get JMS Destinations by name.
  Here, name can be fully qualified to select JMS destinations accurately.
  Fully qualified name can be composed as: <JMS DIRECTION>.<JMS PROVIDER TYPE>.<NAME>
  """
  jmsDestinationsByName(name: String!): [JmsDestination!]!

  """Get JMS Destination by goid"""
  jmsDestinationByGoid(goid: ID!): JmsDestination

  """Get xml schemas configured on this gateway"""
  schemas: [Schema!]!

  """The schema given its system id"""
  schemaBySystemId(systemId: String!): Schema

  """The dtds configured on this gateway"""
  dtds: [Dtd!]!

  """The dtd given its system id"""
  dtdBySystemId(systemId: String!): Dtd

  """Get internal schemas, for reference only"""
  internalSchemas: [Schema!]!

  """Get internal dtds, for reference only"""
  internalDtds: [Dtd!]!

  """Get all internal users"""
  internalUsers: [InternalUser!]!

  """Get all internal groups"""
  internalGroups: [InternalGroup!]!

  """Get internal user by login"""
  internalUserByLogin(login: String!): InternalUser

  """Get internal group by name"""
  internalGroupByName(name: String!): InternalGroup

  """Get internal users and groups"""
  searchInternal(filter: IdpFilter!): InternalSearchResult!

  """Get all fips configurations"""
  fips: [Fip!]!

  """Get all fip users"""
  fipUsers: [FipUser!]!

  """Get all fip groups"""
  fipGroups: [FipGroup!]!

  """Get fip configuration by name"""
  fipByName(name: String!): Fip

  """Get fip user by name"""
  fipUserByName(providerName: String!, name: String!): FipUser

  """Get fip group by name"""
  fipGroupByName(providerName: String!, name: String!): FipGroup
  searchFip(filter: IdpFilter!): FipSearchResult!

  """Get all ldap configurations"""
  ldaps: [Ldap!]!

  """Get ldap configuration by name"""
  ldapByName(name: String!): Ldap

  """Retrieves all secrets"""
  secrets: [Secret!]!

  """Retrieves all keys"""
  keys: [Key!]!

  """Retrieves a secret by name"""
  secretByName(name: String!): Secret

  """Retrieves a key by name"""
  keyByAlias(alias: String!): Key

  """Get all Server module files"""
  serverModuleFiles: [ServerModuleFile!]!

  """Get Server module file by name"""
  serverModuleFileByName(name: String!): ServerModuleFile

  """Retrieves all scheduled tasks"""
  scheduledTasks: [ScheduledTask!]!

  """Retrieves all background task policies"""
  backgroundTaskPolicies: [BackgroundTaskPolicy!]!

  """Retrieves a scheduled task by name"""
  scheduledTaskByName(name: String!): ScheduledTask

  """Retrieves a background task policy by name"""
  backgroundTaskPolicyByName(name: String!): BackgroundTaskPolicy

  """Retrieves background task policies by folder path"""
  backgroundTaskPoliciesByFolderPath(folderPath: String!): [BackgroundTaskPolicy!]!

  """Get all email listeners"""
  emailListeners: [EmailListener!]!

  """Get the email listener by name"""
  emailListenerByName(name: String!): EmailListener

  """Get all listen ports"""
  listenPorts: [ListenPort!]!

  """Get the listen port by name"""
  listenPortByName(name: String!): ListenPort

  """Get the listen ports by protocol"""
  listenPortsByProtocol(protocol: String!): [ListenPort!]!

  """Get all active connectors"""
  activeConnectors: [ActiveConnector!]!

  """Get the active connector by name"""
  activeConnectorByName(name: String!): ActiveConnector

  """Get the active connectors by type"""
  activeConnectorsByType(connectorType: ActiveConnectorType!): [ActiveConnector!]!

  """Get all siteminder configurations"""
  smConfigs: [SMConfig!]!

  """Get the siteminder configuration by name"""
  smConfigByName(name: String!): SMConfig

  """Get Service Resolution Config"""
  serviceResolutionConfig: ServiceResolutionConfig!

  """Get Service Resolution Configs"""
  serviceResolutionConfigs: [ServiceResolutionConfig!]!

  """Get all cluster nodes information"""
  clusterInfo: ClusterInfo!

  """Get Password Policy"""
  passwordPolicy: PasswordPolicy!

  """Get Password Policies"""
  passwordPolicies: [PasswordPolicy!]!

  """Get all RevocationCheckPolicies"""
  revocationCheckPolicies: [RevocationCheckPolicy!]!

  """Get the RevocationCheckPolicy by name"""
  revocationCheckPolicyByName(name: String!): RevocationCheckPolicy

  """
  Get all administrative user account minimum properties :
  logonMaxAllowableAttempts, logonLockoutTime, logonSessionExpiry,
  logonInactivityPeriod
  """
  administrativeUserAccountProperties: [AdministrativeUserAccountProperty!]!

  """Get all http configuration"""
  httpConfigurations: [HttpConfiguration!]!

  """Get the http configuration with the given host"""
  httpConfigurationsByHost(host: String!): [HttpConfiguration!]!

  """Get all Folders"""
  folders: [Folder!]!

  """Get the folder identified by path"""
  folderByPath(path: String!): Folder!

  """
  Get the folders matches by path (i.e., folder itself and the folders in it)
  """
  foldersByPath(path: String!): [Folder!]!

  """Get All LogSinks"""
  logSinks: [LogSink!]!

  """Get the LogSink with the given name"""
  logSinkByName(name: String!): LogSink
}

type RevocationCheckPoliciesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  revocationCheckPolicies: [RevocationCheckPolicy]!
}

type RevocationCheckPolicy {
  """The goid for this revocation check policy"""
  goid: ID!

  """Name that describes the revocation checking policy"""
  name: String!

  """The configuration checksum of this Revocation check policy"""
  checksum: String!

  """Use as default revocation check policy"""
  defaultPolicy: Boolean!

  """Succeed if revocation status is unknown"""
  defaultSuccess: Boolean!

  """Continue processing if server is unavailable"""
  continueOnServerUnavailable: Boolean!

  """Certificate revocation check properties"""
  revocationCheckPolicyItems: [RevocationCheckPolicyItem!]!
}

input RevocationCheckPolicyInput {
  """The goid for this revocation check policy"""
  goid: ID

  """Name that describes the revocation checking policy"""
  name: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String

  """Use as default revocation check policy"""
  defaultPolicy: Boolean!

  """Succeed if revocation status is unknown"""
  defaultSuccess: Boolean!

  """Continue processing if server is unavailable"""
  continueOnServerUnavailable: Boolean!

  """Certificate revocation check properties"""
  revocationCheckPolicyItems: [RevocationCheckPolicyItemInput!]!
}

type RevocationCheckPolicyItem {
  """Type for Checking OCSP or CRL"""
  type: CertRevocationCheckPropertyType!

  """
  If the CRL from URL or OCSP from URL option was selected, enter the URL
  """
  url: String

  """If user permitting the entity that issued the certificate"""
  allowIssuerSignature: Boolean!

  """Whether to include a nonce in OCSP request"""
  nonceUsage: OcspNonceUsage

  """The sha1 thumbprint of the certificate"""
  signerThumbprintSha1s: [String!]
}

input RevocationCheckPolicyItemInput {
  """Type for Checking OCSP or CRL"""
  type: CertRevocationCheckPropertyType!

  """
  If the CRL from URL or OCSP from URL option was selected, enter the URL Otherwise provide regex.
  CRL_FROM_CERTIFICATE &  OCSP_FROM_CERTIFICATE options uses URL Regex &
  CRL_FROM_URL & OCSP_FROM_URL options uses URLs.
  This is caller's responsibility to provide valid URL or Regex, Graphman won't validate it.
  """
  url: String!

  """If user permitting the entity that issued the certificate"""
  allowIssuerSignature: Boolean!

  """
  Whether to include a nonce in OCSP request, default is to set INCLUDE_NONCE
  """
  nonceUsage: OcspNonceUsage = INCLUDE_NONCE

  """The sha1 thumbprint of the certificate"""
  signerThumbprintSha1s: [String]
}

"""A scheduled task"""
type ScheduledTask {
  """The internal entity unique identifier"""
  goid: ID!

  """The name of the scheduled task"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """The name of the policy for scheduled task"""
  policyName: String!

  """Scheduled task type"""
  jobType: JobType!

  """The cron job expression"""
  cronExpression: String

  """Whether to execute on single node"""
  executeOnSingleNode: Boolean!

  """Whether to execute the RECURRING task now?"""
  executeOnCreation: Boolean!

  """Execution date of a ONE_TIME task"""
  executionDate: DateTime

  """The scheduled task status"""
  status: JobStatus!
  runAsUser: String
  runAsUserProviderName: String
}

input ScheduledTaskInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the scheduled task"""
  name: String!

  """The name of the policy for scheduled task"""
  policyName: String!
  jobType: JobType!

  """The cron job expression"""
  cronExpression: String

  """Whether to execute on single node"""
  executeOnSingleNode: Boolean!

  """Whether to execute the RECURRING task now?"""
  executeOnCreation: Boolean!

  """Specify a future execution date for a ONE_TIME task"""
  executionDate: DateTime

  """The scheduled task status"""
  status: JobStatus = SCHEDULED
  runAsUser: String
  runAsUserProviderName: String

  """The configuration checksum"""
  checksum: String
}

type ScheduledTasksPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  scheduledTasks: [ScheduledTask]!
}

"""
An XML Schema which can be referred to in policy, for example in the validate xml schema assertion
"""
type Schema {
  """Internal goid for this schema"""
  goid: ID!

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The configuration checksum"""
  checksum: String!

  """The target namespace in the xml schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!
}

input SchemaInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  A reference to the schema. This id is what is referred to in policy and is often mirror of the target namespace
  """
  systemId: String!

  """The target namespace in the XML schema"""
  targetNs: String

  """An optional description for the schema"""
  description: String

  """The content of XML schema"""
  content: String!

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type SchemasPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  schemas: [Schema]!
}

"""
These secrets are used by gateway policies also for example by jdbc connection configurations
"""
type Secret {
  """The goid for the Secret"""
  goid: ID!

  """
  Identify the password being stored. You may use letters, numbers, dashes, and underscores.
  Names that contain spaces or periods are valid, but the resulting stored
  password cannot be referenced via context variable.
  Names that contain @ or $ are valid, but the resulting stored password cannot be referenced via context variable.
  """
  name: String!

  """The configuration checksum"""
  checksum: String!

  """Description of the password. This is optional"""
  description: String

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can decrypt these values at command line
  using this command:
  > echo <secret> | openssl enc -d -aes-256-cbc -md sha256 -pass pass:<passphrase> -a
  """
  secret: String!

  """Password or PEM Private Key"""
  secretType: SecretType!

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!
}

input SecretInput {
  """
  Identify the password being stored. You may use letters, numbers, dashes, and underscores.
  Names that contain spaces or periods are valid, but the resulting stored
  password cannot be referenced via context variable.
  Names that contain @ or $ are valid, but the resulting stored password cannot be referenced via context variable.
  """
  name: String!

  """Password or PEM Private Key"""
  secretType: SecretType!

  """The goid for the Secret"""
  goid: ID

  """
  Ignored at entity creation time but declared here so you can embed checksums in graphman bundles
  """
  checksum: String

  """
  Whether this secret can be referred to in policy via context variable ${secpass... 
  """
  variableReferencable: Boolean!

  """
  Base64 encrypted secret. The encryption is compatible with openssl secret encryption
  using cypher AES/CBC/PKCS5Padding. You can create this value at command line:
  > echo -n "<clear text secret>" | openssl enc -aes-256-cbc -md sha256 -pass pass:<password> -a
  """
  secret: String!

  """Description of the password. This is optional"""
  description: String
}

type SecretsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  secrets: [Secret]!
}

enum SecretType {
  """Stored password for example used in the jdbc connection"""
  PASSWORD

  """Secure pem key for example used in the route via ssh assertion"""
  PEM_PRIVATE_KEY
}

"""A Server module file"""
type ServerModuleFile {
  """The goid for the Server module file"""
  goid: ID!

  """The Server module name"""
  name: String!

  """The configuration checksum of this Server module file"""
  checksum: String!

  """The Server module type"""
  moduleType: ModuleType!

  """The Server module SHA256 digest value"""
  moduleSha256: String!

  """The Server module signature"""
  signature: String!

  """The base64 encoded signer certificate"""
  signerCertBase64: String!

  """The Server module file properties"""
  properties: [EntityProperty!]!

  """The Server module file state per node in the cluster"""
  moduleStates: [ServerModuleFileState!]!
  moduleStateSummary: ServerModuleFileStateSummary!

  """
  The dummy field, is used to get the Server module file content in separate part
  """
  filePartName: String!
}

input ServerModuleFileInput {
  """The internal entity unique identifier"""
  goid: ID

  """The Server module name"""
  name: String!

  """The Server module type"""
  moduleType: ModuleType

  """The Server module SHA256 digest value"""
  moduleSha256: String

  """The Server module signature"""
  signature: String

  """The base64 encoded signer certificate"""
  signerCertBase64: String

  """The Server module file properties"""
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type ServerModuleFilesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!

  """The created Server module files."""
  serverModuleFiles: [ServerModuleFile]!
}

type ServerModuleFileState {
  nodeId: String!
  nodeName: String!
  state: ModuleState!
  description: String
}

type ServerModuleFileStateSummary {
  state: ModuleStateSummary!
  description: String
}

type ServiceResolutionConfig {
  """The internal entity unique identifier"""
  goid: ID!

  """The configuration checksum"""
  checksum: String!

  """Only Services with a resolution path are accessible"""
  resolutionPathRequired: Boolean!

  """Resolution paths are case sensitive"""
  resolutionPathCaseSensitive: Boolean!

  """Allow resolution by L7-Original-URL header"""
  useL7OriginalUrl: Boolean!

  """Allow resolution by Service GOID/OID in URLs"""
  useServiceGoid: Boolean!

  """Use SOAP action"""
  useSoapAction: Boolean!

  """Use SOAP body child namespace"""
  useSoapBodyChildNamespace: Boolean!
}

input ServiceResolutionConfigInput {
  """The internal entity unique identifier"""
  goid: ID

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String

  """Only Services with a resolution path are accessible"""
  resolutionPathRequired: Boolean!

  """Resolution paths are case sensitive"""
  resolutionPathCaseSensitive: Boolean!

  """Allow resolution by L7-Original-URL header"""
  useL7OriginalUrl: Boolean!

  """Allow resolution by Service GOID/OID in URLs"""
  useServiceGoid: Boolean!

  """Use SOAP action"""
  useSoapAction: Boolean!

  """Use SOAP body child namespace"""
  useSoapBodyChildNamespace: Boolean!
}

type ServiceResolutionConfigsPayLoad {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  serviceResolutionConfigs: [ServiceResolutionConfig]!
}

type SMConfig {
  """The goid for the CA SSO connection"""
  goid: ID!

  """Name of the CA SSO configuration"""
  name: String!

  """The configuration checksum"""
  checksum: String!

  """
  Indicates whether the specified configuration is currently enabled or disabled
  """
  enabled: Boolean!

  """Name of the host registered with the CA SSO Policy Server"""
  agentHost: String!

  """
  The IP address of the CA SSO agent. This field is required if the Check IP check box is selected
  """
  agentIP: String!

  """CA SSO Policy Server host configuration used by the agent"""
  agentHostConfig: String!

  """
  CA SSO shared secret used by the agent to establish communication with the Policy Server
  """
  agentSecret: String!

  """
  Choose the FIPS mode supported by the CA SSO Policy Server. The available values are: COMPAT(default)/MIGRATE/ONLY
  """
  cryptoMode: SMCryptoMode!

  """
  The CA SSO Policy Server compare the client IP against the address stored in the SSO Token
  """
  ipCheckEnabled: Boolean!

  """
  Whether to update the SSO Token after successful authentication/authorization
  """
  updateSSOToken: Boolean!

  """
  The percentage of servers within a cluster that must be available for Policy Server requests
  """
  clusterFailoverThreshold: PositiveInt!
  nonClusterFailover: Boolean!

  """User name of the CA SSO administrator"""
  username: String!

  """The secure password reference"""
  securePasswordName: String!

  """The Siteminder configuration properties"""
  properties: [EntityProperty!]
}

input SMConfigInput {
  """The goid for the CA SSO connection"""
  goid: ID

  """Name of the CA SSO configuration"""
  name: String!

  """
  Indicates whether the specified configuration is currently enabled or disabled
  """
  enabled: Boolean!

  """Name of the host registered with the CA SSO Policy Server"""
  agentHost: String!

  """
  The IP address of the CA SSO agent. This field is required if the Check IP check box is selected
  """
  agentIP: String!

  """CA SSO Policy Server host configuration used by the agent"""
  agentHostConfig: String!

  """
  CA SSO shared secret used by the agent to establish communication with the Policy Server
  """
  agentSecret: String!

  """
  Choose the FIPS mode supported by the CA SSO Policy Server. The available values are: COMPAT(default)/MIGRATE/ONLY
  """
  cryptoMode: SMCryptoMode!

  """
  The CA SSO Policy Server compare the client IP against the address stored in the SSO Token
  """
  ipCheckEnabled: Boolean!

  """
  Whether to update the SSO Token after successful authentication/authorization
  """
  updateSSOToken: Boolean!

  """
  The percentage of servers within a cluster that must be available for Policy Server requests
  """
  clusterFailoverThreshold: PositiveInt!
  nonClusterFailover: Boolean!

  """User name of the CA SSO administrator"""
  username: String!

  """The secure password reference"""
  securePasswordName: String!

  """The Siteminder configuration properties"""
  properties: [EntityPropertyInput!]

  """The configuration checksum"""
  checksum: String
}

type SMConfigsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  smConfigs: [SMConfig]!
}

enum SMCryptoMode {
  COMPAT
  MIGRATE
  FIPS
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
type SoapResolvers {
  """The soap actions referred to in the wsdl"""
  soapActions: [String!]!

  """
  Base uri from the wsdl of the service. This is used for service resolution
  """
  baseUri: String

  """The resolution path to the service if not default /ssg/soap"""
  resolutionPath: String
}

"""A Soap service published on the Layer7 Gateway"""
type SoapService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String

  """Soap service resolvers"""
  resolvers: SoapResolvers!

  """The configuration checksum"""
  checksum: String!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """The folder path to the service"""
  folderPath: String!

  """Which SOAP version"""
  soapVersion: SoapVersion!

  """Which http methods are allowed if not just POST"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean
  properties: [EntityProperty!]

  """The WSDL of the soap service"""
  wsdl: String!

  """The policy and dependencies"""
  policy: Policy!
}

input SoapServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: String!

  """The name of the service"""
  name: String!

  """The WSDL of the soap service"""
  wsdl: String!

  """The resolution path of the service"""
  resolutionPath: String = "/ssg/soap"

  """Soap service resolvers"""
  resolvers: SoapServiceResolverInput

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default true)"""
  enabled: Boolean = true

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!

  """Which SOAP version"""
  soapVersion: SoapVersion = UNKNOWN

  """
  Whether or not the gateway should process incoming ws-security soap headers
  """
  wssProcessingEnabled: Boolean!
  tracingEnabled: Boolean = false

  """Allow requests intended for operations not supported by the WSDL"""
  laxResolution: Boolean = false
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

""" Must have minimum (1 soapAction + baseUri) OR resolutionPath. You can have both too. 
"""
input SoapServiceResolverInput {
  """
  One of the SoapAction of the service to resolved. This must be specified along with a base ns from the WSDL
  """
  soapAction: String

  """
  One or more soap actions of the service to resolved. This must be specified in the absence of soapAction field.
  """
  soapActions: [String!]

  """
  Base uri from the wsdl of the service. Use this alongside the soapaction
  property to resolve a soap service without resolutionUri
  """
  baseUri: String

  """
  The resolution path of the service if that is how the soap service is resolved
  """
  resolutionPath: String
}

type SoapServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  soapServices: [SoapService]!
}

enum SoapVersion {
  SOAP_1_1
  SOAP_1_2
  UNKNOWN
}

"""Input sent with createTrustedCert mutation"""
input TrustedCertInput {
  """The internal entity unique identifier"""
  goid: ID

  """The name of the trusted certificate"""
  name: String!

  """The base 64 encoded string of the certificate"""
  certBase64: String!

  """Whether to perform hostname verification with this certificate"""
  verifyHostname: Boolean!

  """Whether this certificate is a trust anchor"""
  trustAnchor: Boolean!

  """What the certificate is trusted for"""
  trustedFor: [TrustedForType!]!

  """The revocation check policy type"""
  revocationCheckPolicyType: PolicyUsageType!

  """
  The name of revocation policy.  Required if revocationCheckPolicyType is PolicyUsageType.SPECIFIED
  """
  revocationCheckPolicyName: String

  """
  The Subject DN of this certificate. (Note that, this field has no effect on the mutation)
  """
  subjectDn: String

  """
  The start date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notBefore: String

  """
  the end date of the validity period. (Note that, this field has no effect on the mutation)
  """
  notAfter: String

  """
  The sha1 thumbprint of the certificate. (Note that, this field has no effect on the mutation)
  """
  thumbprintSha1: String

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type TrustedCertsPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  trustedCerts: [Certificate]!
}

"""Defines what a certificate is trusted for"""
enum TrustedForType {
  """Is trusted as an SSL server cert"""
  SSL

  """Is trusted as a CA that signs SSL server certs"""
  SIGNING_SERVER_CERTS

  """Is trusted as a CA that signs SSL client certs"""
  SIGNING_CLIENT_CERTS

  """Is trusted to sign SAML tokens"""
  SAML_ISSUER

  """Is trusted as a SAML attesting entity"""
  SAML_ATTESTING_ENTITY
}

type UserMapping {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategy!
}

input UserMappingInput {
  objClass: String!
  nameAttrName: String!
  loginAttrName: String!
  passwdAttrName: String
  firstNameAttrName: String
  lastNameAttrName: String
  emailNameAttrName: String
  kerberosAttrName: String
  kerberosEnterpriseAttrName: String
  userCertAttrName: String
  passwdType: PasswdStrategyInput!
}

"""A Web API service published on the Layer7 Gateway"""
type WebApiService implements PublishedService {
  """The goid for this service"""
  goid: ID!

  """The guid for this service"""
  guid: ID

  """The name of the service"""
  name: String!

  """The resolution path to the service"""
  resolutionPath: String!

  """The configuration checksum"""
  checksum: String!

  """Whether or not the published service is enabled"""
  enabled: Boolean!

  """The folder path to the service"""
  folderPath: String!

  """Which http methods are allowed"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean!
  wssProcessingEnabled: Boolean!
  properties: [EntityProperty!]

  """The policy and dependencies"""
  policy: Policy!
}

input WebApiServiceInput {
  """The internal entity unique identifier"""
  goid: ID

  """The guid for this service, if none provided, assigned at creation"""
  guid: ID

  """
  The folder path where to create this service.  If the path does not exist, it will be created
  """
  folderPath: NonEmptyString!

  """The name of the service"""
  name: String!

  """The resolution path of the service"""
  resolutionPath: String!

  """The policy"""
  policy: PolicyInput!

  """Whether the service is enabled (optional, default to true)"""
  enabled: Boolean = true

  """The http methods allowed for this service"""
  methodsAllowed: [HttpMethod!]!
  tracingEnabled: Boolean = false
  wssProcessingEnabled: Boolean = false
  properties: [EntityPropertyInput!]

  """
  Ignored at creation time but can be used to compare bundle with gw state
  """
  checksum: String
}

type WebApiServicesPayload implements EntityMutationsPayload {
  status: [EntityMutationStatus!]!
  detailedStatus: [EntityMutationDetailedStatus!]!
  webApiServices: [WebApiService]!
}

